"use strict";Object.defineProperty(exports,"__esModule",{value:!0});class t{constructor(t,e){this.operator=t,this.value=e,Object.defineProperty(this,"t",{writable:!0})}get notes(){return this.t}addNote(t){this.t=this.t||[],this.t.push(t)}}class e extends t{}class r extends e{constructor(t,e){if(!Array.isArray(e))throw new Error(`"${t}" operator expects to receive an array of conditions`);super(t,e)}}class o extends t{constructor(t,e,r){super(t,r),this.field=e}}const s=new e("__null__",null);function n(t,e){const r=t[e];if("function"!=typeof r)throw new Error(`Unable to interpret "${e}" condition. Did you forget to register interpreter for it?`);return r}function i(t){return t.operator}function c(t,e){return e instanceof r&&e.operator===t}function u(t,e){return 1===e.length?e[0]:new r(t,function t(e,r,o){const s=o||[];for(let o=0,n=r.length;o<n;o++){const n=r[o];c(e,n)?t(e,n.value,s):s.push(n)}return s}(t,e))}const a=t=>t;function p(t,e){if(!t||t&&t.constructor!==Object)return!1;for(const r in t)if(t.hasOwnProperty(r)&&e.hasOwnProperty(r))return!0;return!1}const h=()=>Object.create(null),f=t=>u("and",t),l={compound(t,e,o){const s=(Array.isArray(e)?e:[e]).map(t=>o.parse(t));return new r(t.name,s)},field:(t,e,r)=>new o(t.name,r.field,e),document:(t,r)=>new e(t.name,r)};function d(t,e,r){"function"==typeof t.validate&&t.validate(t,e);return(t.parse||l[t.type])(t,e,r)}exports.CompoundCondition=r,exports.Condition=t,exports.DocumentCondition=e,exports.FieldCondition=o,exports.ITSELF="__itself__",exports.NULL_CONDITION=s,exports.ObjectQueryParser=class{constructor(t,e=h()){this.o=void 0,this.s=void 0,this.i=void 0,this.u=void 0,this.parse=this.parse.bind(this),this.u={operatorToConditionName:e.operatorToConditionName||a,defaultOperatorName:e.defaultOperatorName||"eq"},this.o=Object.keys(t).reduce((e,r)=>(e[r]=Object.assign({name:this.u.operatorToConditionName(r)},t[r]),e),{}),this.s=Object.assign({},e.fieldContext,{field:"",query:{},parse:this.parse,hasOperators:t=>p(t,this.o)}),this.i=Object.assign({},e.documentContext,{parse:this.parse,query:{}})}setParse(t){this.parse=t,this.s.parse=t,this.i.parse=t}parseField(t,e,r,o){const s=this.o[e];if(!s)throw new Error(`Unsupported operator "${e}"`);if("field"!==s.type)throw new Error(`Unexpected ${s.type} operator "${e}" at field level`);return this.s.field=t,this.s.query=o,d(s,r,this.s)}parseFieldOperators(t,e){const r=[],o=Object.keys(e);for(let n=0,i=o.length;n<i;n++){const i=o[n];if(!this.o[i])throw new Error(`Field query for "${t}" may contain only operators or a plain object as a value`);const c=this.parseField(t,i,e[i],e);c!==s&&r.push(c)}return r}parse(t){const e=[],r=Object.keys(t);this.i.query=t;for(let o=0,s=r.length;o<s;o++){const s=r[o],n=t[s],i=this.o[s];if(i){if("document"!==i.type&&"compound"!==i.type)throw new Error(`Cannot use parsing instruction for operator "${s}" in "document" context as it is supposed to be used in  "${i.type}" context`);e.push(d(i,n,this.i))}else p(n,this.o)?e.push(...this.parseFieldOperators(s,n)):e.push(this.parseField(s,this.u.defaultOperatorName,n,t))}return f(e)}},exports.buildAnd=f,exports.buildOr=t=>u("or",t),exports.createInterpreter=function(t,e){const r=e,o=r&&r.getInterpreterName||i;let s;switch(r?r.numberOfArguments:0){case 1:s=e=>{const s=o(e,r);return n(t,s)(e,c)};break;case 3:s=(e,s,i)=>{const u=o(e,r);return n(t,u)(e,s,i,c)};break;default:s=(e,s)=>{const i=o(e,r);return n(t,i)(e,s,c)}}const c=Object.assign({},r,{interpret:s});return c.interpret},exports.createTranslatorFactory=function(t,e){return(r,...o)=>{const s=t(r,...o),n=e.bind(null,s);return n.ast=s,n}},exports.defaultInstructionParsers=l,exports.hasOperators=p,exports.identity=a,exports.isCompound=c,exports.object=h,exports.optimizedCompoundCondition=u,exports.parseInstruction=d;
//# sourceMappingURL=index.js.map
