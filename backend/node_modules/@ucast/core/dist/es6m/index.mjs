class t{constructor(t,e){this.operator=t,this.value=e,Object.defineProperty(this,"t",{writable:!0})}get notes(){return this.t}addNote(t){this.t=this.t||[],this.t.push(t)}}class e extends t{}class r extends e{constructor(t,e){if(!Array.isArray(e))throw new Error(`"${t}" operator expects to receive an array of conditions`);super(t,e)}}const n="__itself__";class o extends t{constructor(t,e,r){super(t,r),this.field=e}}const s=new e("__null__",null);function i(t,e){const r=t[e];if("function"!=typeof r)throw new Error(`Unable to interpret "${e}" condition. Did you forget to register interpreter for it?`);return r}function c(t){return t.operator}function u(t,e){const r=e,n=r&&r.getInterpreterName||c;let o;switch(r?r.numberOfArguments:0){case 1:o=e=>{const o=n(e,r);return i(t,o)(e,s)};break;case 3:o=(e,o,c)=>{const u=n(e,r);return i(t,u)(e,o,c,s)};break;default:o=(e,o)=>{const c=n(e,r);return i(t,c)(e,o,s)}}const s=Object.assign({},r,{interpret:o});return s.interpret}function a(t,e){return(r,...n)=>{const o=t(r,...n),s=e.bind(null,o);return s.ast=o,s}}function h(t,e){return e instanceof r&&e.operator===t}function f(t,e){return 1===e.length?e[0]:new r(t,function t(e,r,n){const o=n||[];for(let n=0,s=r.length;n<s;n++){const s=r[n];h(e,s)?t(e,s.value,o):o.push(s)}return o}(t,e))}const l=t=>t;function d(t,e){if(!t||t&&t.constructor!==Object)return!1;for(const r in t)if(t.hasOwnProperty(r)&&e.hasOwnProperty(r))return!0;return!1}const p=()=>Object.create(null),w=t=>f("and",t),b=t=>f("or",t),O={compound(t,e,n){const o=(Array.isArray(e)?e:[e]).map(t=>n.parse(t));return new r(t.name,o)},field:(t,e,r)=>new o(t.name,r.field,e),document:(t,r)=>new e(t.name,r)};function j(t,e,r){"function"==typeof t.validate&&t.validate(t,e);return(t.parse||O[t.type])(t,e,r)}class y{constructor(t,e=p()){this.o=void 0,this.s=void 0,this.i=void 0,this.u=void 0,this.parse=this.parse.bind(this),this.u={operatorToConditionName:e.operatorToConditionName||l,defaultOperatorName:e.defaultOperatorName||"eq"},this.o=Object.keys(t).reduce((e,r)=>(e[r]=Object.assign({name:this.u.operatorToConditionName(r)},t[r]),e),{}),this.s=Object.assign({},e.fieldContext,{field:"",query:{},parse:this.parse,hasOperators:t=>d(t,this.o)}),this.i=Object.assign({},e.documentContext,{parse:this.parse,query:{}})}setParse(t){this.parse=t,this.s.parse=t,this.i.parse=t}parseField(t,e,r,n){const o=this.o[e];if(!o)throw new Error(`Unsupported operator "${e}"`);if("field"!==o.type)throw new Error(`Unexpected ${o.type} operator "${e}" at field level`);return this.s.field=t,this.s.query=n,j(o,r,this.s)}parseFieldOperators(t,e){const r=[],n=Object.keys(e);for(let o=0,i=n.length;o<i;o++){const i=n[o];if(!this.o[i])throw new Error(`Field query for "${t}" may contain only operators or a plain object as a value`);const c=this.parseField(t,i,e[i],e);c!==s&&r.push(c)}return r}parse(t){const e=[],r=Object.keys(t);this.i.query=t;for(let n=0,o=r.length;n<o;n++){const o=r[n],s=t[o],i=this.o[o];if(i){if("document"!==i.type&&"compound"!==i.type)throw new Error(`Cannot use parsing instruction for operator "${o}" in "document" context as it is supposed to be used in  "${i.type}" context`);e.push(j(i,s,this.i))}else d(s,this.o)?e.push(...this.parseFieldOperators(o,s)):e.push(this.parseField(o,this.u.defaultOperatorName,s,t))}return w(e)}}export{r as CompoundCondition,t as Condition,e as DocumentCondition,o as FieldCondition,n as ITSELF,s as NULL_CONDITION,y as ObjectQueryParser,w as buildAnd,b as buildOr,u as createInterpreter,a as createTranslatorFactory,O as defaultInstructionParsers,d as hasOperators,l as identity,h as isCompound,p as object,f as optimizedCompoundCondition,j as parseInstruction};
//# sourceMappingURL=index.mjs.map
