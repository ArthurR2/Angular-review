
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model User
 */

export type User = {
  id: string
  email: string
  passwordHash: string | null
  firstName: string | null
  middleName: string | null
  lastName: string | null
  nickName: string | null
  profilePicture: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Book
 */

export type Book = {
  id: string
  title: string
  publisherId: string
  publishYear: number
  isbn: number
  description: string
  price: number
  coverUrl: string | null
  coverDataUri: string | null
  sold: number
  transactionId: string | null
  shoppingCartId: string | null
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Author
 */

export type Author = {
  id: string
  firstName: string
  middleName: string | null
  lastName: string
  description: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Publisher
 */

export type Publisher = {
  id: string
  name: string
  city: string
  state: string
  website: string | null
}

/**
 * Model Genre
 */

export type Genre = {
  id: number
  name: string
}

/**
 * Model Review
 */

export type Review = {
  id: string
  value: number
  description: string
  postedAs: string
  createdAt: Date
  updatedAt: Date
  userId: string
  bookId: string
}

/**
 * Model Address
 */

export type Address = {
  id: string
  street: string
  apartmentOrUnit: string | null
  city: string
  state: string
  country: string
  zipcode: string
  userShippingAddressId: string
}

/**
 * Model Transaction
 */

export type Transaction = {
  id: string
  userId: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model CreditCard
 */

export type CreditCard = {
  id: string
  userId: string
  encryptedCreditCardNumber: string
  encryptedCCV: string
  lastFourDigits: string
  expirationDate: Date
  createdAt: Date
  updatedAt: Date
}

/**
 * Model ShoppingCart
 */

export type ShoppingCart = {
  id: string
  userId: string
  createdAt: Date
  updatedAt: Date
}

/**
 * Model Role
 */

export type Role = {
  id: number
  name: string
}

/**
 * Model Log
 */

export type Log = {
  id: string
  name: string
  message: string
  createdAt: Date
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.book`: Exposes CRUD operations for the **Book** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Books
    * const books = await prisma.book.findMany()
    * ```
    */
  get book(): Prisma.BookDelegate<GlobalReject>;

  /**
   * `prisma.author`: Exposes CRUD operations for the **Author** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Authors
    * const authors = await prisma.author.findMany()
    * ```
    */
  get author(): Prisma.AuthorDelegate<GlobalReject>;

  /**
   * `prisma.publisher`: Exposes CRUD operations for the **Publisher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Publishers
    * const publishers = await prisma.publisher.findMany()
    * ```
    */
  get publisher(): Prisma.PublisherDelegate<GlobalReject>;

  /**
   * `prisma.genre`: Exposes CRUD operations for the **Genre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Genres
    * const genres = await prisma.genre.findMany()
    * ```
    */
  get genre(): Prisma.GenreDelegate<GlobalReject>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<GlobalReject>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<GlobalReject>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<GlobalReject>;

  /**
   * `prisma.creditCard`: Exposes CRUD operations for the **CreditCard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditCards
    * const creditCards = await prisma.creditCard.findMany()
    * ```
    */
  get creditCard(): Prisma.CreditCardDelegate<GlobalReject>;

  /**
   * `prisma.shoppingCart`: Exposes CRUD operations for the **ShoppingCart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShoppingCarts
    * const shoppingCarts = await prisma.shoppingCart.findMany()
    * ```
    */
  get shoppingCart(): Prisma.ShoppingCartDelegate<GlobalReject>;

  /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<GlobalReject>;

  /**
   * `prisma.log`: Exposes CRUD operations for the **Log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.log.findMany()
    * ```
    */
  get log(): Prisma.LogDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.18.0
   * Query Engine version: da6fafb57b24e0b61ca20960c64e2d41f9e8cff1
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  export type Union = any

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, 'avg' | 'sum' | 'count' | 'min' | 'max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    User: 'User',
    Book: 'Book',
    Author: 'Author',
    Publisher: 'Publisher',
    Genre: 'Genre',
    Review: 'Review',
    Address: 'Address',
    Transaction: 'Transaction',
    CreditCard: 'CreditCard',
    ShoppingCart: 'ShoppingCart',
    Role: 'Role',
    Log: 'Log'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }


  /**
   * Model User
   */


  export type AggregateUser = {
    count: UserCountAggregateOutputType | null
    min: UserMinAggregateOutputType | null
    max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    nickName: string | null
    profilePicture: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    nickName: string | null
    profilePicture: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number | null
    email: number | null
    passwordHash: number | null
    firstName: number | null
    middleName: number | null
    lastName: number | null
    nickName: number | null
    profilePicture: number | null
    createdAt: number | null
    updatedAt: number | null
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    middleName?: true
    lastName?: true
    nickName?: true
    profilePicture?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    middleName?: true
    lastName?: true
    nickName?: true
    profilePicture?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    firstName?: true
    middleName?: true
    lastName?: true
    nickName?: true
    profilePicture?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }



  export type UserSelect = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    nickName?: boolean
    profilePicture?: boolean
    transactions?: boolean | TransactionFindManyArgs
    shippingAddresses?: boolean | AddressFindManyArgs
    creditCards?: boolean | CreditCardFindManyArgs
    roles?: boolean | RoleFindManyArgs
    reviews?: boolean | ReviewFindManyArgs
    shoppingCart?: boolean | ShoppingCartFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude = {
    transactions?: boolean | TransactionFindManyArgs
    shippingAddresses?: boolean | AddressFindManyArgs
    creditCards?: boolean | CreditCardFindManyArgs
    roles?: boolean | RoleFindManyArgs
    reviews?: boolean | ReviewFindManyArgs
    shoppingCart?: boolean | ShoppingCartFindManyArgs
  }

  export type UserGetPayload<
    S extends boolean | null | undefined | UserArgs,
    U = keyof S
      > = S extends true
        ? User
    : S extends undefined
    ? never
    : S extends UserArgs | UserFindManyArgs
    ?'include' extends U
    ? User  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'transactions'
        ? Array < TransactionGetPayload<S['include'][P]>>  :
        P extends 'shippingAddresses'
        ? Array < AddressGetPayload<S['include'][P]>>  :
        P extends 'creditCards'
        ? Array < CreditCardGetPayload<S['include'][P]>>  :
        P extends 'roles'
        ? Array < RoleGetPayload<S['include'][P]>>  :
        P extends 'reviews'
        ? Array < ReviewGetPayload<S['include'][P]>>  :
        P extends 'shoppingCart'
        ? Array < ShoppingCartGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof User ?User [P]
  : 
          P extends 'transactions'
        ? Array < TransactionGetPayload<S['select'][P]>>  :
        P extends 'shippingAddresses'
        ? Array < AddressGetPayload<S['select'][P]>>  :
        P extends 'creditCards'
        ? Array < CreditCardGetPayload<S['select'][P]>>  :
        P extends 'roles'
        ? Array < RoleGetPayload<S['select'][P]>>  :
        P extends 'reviews'
        ? Array < ReviewGetPayload<S['select'][P]>>  :
        P extends 'shoppingCart'
        ? Array < ShoppingCartGetPayload<S['select'][P]>>  : never
  } 
    : User
  : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>> : CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): CheckSelect<T, Prisma__UserClient<User>, Prisma__UserClient<UserGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    transactions<T extends TransactionFindManyArgs = {}>(args?: Subset<T, TransactionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Transaction>>, PrismaPromise<Array<TransactionGetPayload<T>>>>;

    shippingAddresses<T extends AddressFindManyArgs = {}>(args?: Subset<T, AddressFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Address>>, PrismaPromise<Array<AddressGetPayload<T>>>>;

    creditCards<T extends CreditCardFindManyArgs = {}>(args?: Subset<T, CreditCardFindManyArgs>): CheckSelect<T, PrismaPromise<Array<CreditCard>>, PrismaPromise<Array<CreditCardGetPayload<T>>>>;

    roles<T extends RoleFindManyArgs = {}>(args?: Subset<T, RoleFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Role>>, PrismaPromise<Array<RoleGetPayload<T>>>>;

    reviews<T extends ReviewFindManyArgs = {}>(args?: Subset<T, ReviewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Review>>, PrismaPromise<Array<ReviewGetPayload<T>>>>;

    shoppingCart<T extends ShoppingCartFindManyArgs = {}>(args?: Subset<T, ShoppingCartFindManyArgs>): CheckSelect<T, PrismaPromise<Array<ShoppingCart>>, PrismaPromise<Array<ShoppingCartGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Throw an Error if a User can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which User to fetch.
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
    **/
    orderBy?: Enumerable<UserOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: UserInclude | null
  }



  /**
   * Model Book
   */


  export type AggregateBook = {
    count: BookCountAggregateOutputType | null
    avg: BookAvgAggregateOutputType | null
    sum: BookSumAggregateOutputType | null
    min: BookMinAggregateOutputType | null
    max: BookMaxAggregateOutputType | null
  }

  export type BookAvgAggregateOutputType = {
    publishYear: number
    isbn: number
    price: number
    sold: number
  }

  export type BookSumAggregateOutputType = {
    publishYear: number
    isbn: number
    price: number
    sold: number
  }

  export type BookMinAggregateOutputType = {
    id: string | null
    title: string | null
    publisherId: string | null
    publishYear: number
    isbn: number
    description: string | null
    price: number
    coverUrl: string | null
    coverDataUri: string | null
    sold: number
    transactionId: string | null
    shoppingCartId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookMaxAggregateOutputType = {
    id: string | null
    title: string | null
    publisherId: string | null
    publishYear: number
    isbn: number
    description: string | null
    price: number
    coverUrl: string | null
    coverDataUri: string | null
    sold: number
    transactionId: string | null
    shoppingCartId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookCountAggregateOutputType = {
    id: number | null
    title: number | null
    publisherId: number | null
    publishYear: number
    isbn: number
    description: number | null
    price: number
    coverUrl: number | null
    coverDataUri: number | null
    sold: number
    transactionId: number | null
    shoppingCartId: number | null
    createdAt: number | null
    updatedAt: number | null
    _all: number
  }


  export type BookAvgAggregateInputType = {
    publishYear?: true
    isbn?: true
    price?: true
    sold?: true
  }

  export type BookSumAggregateInputType = {
    publishYear?: true
    isbn?: true
    price?: true
    sold?: true
  }

  export type BookMinAggregateInputType = {
    id?: true
    title?: true
    publisherId?: true
    publishYear?: true
    isbn?: true
    description?: true
    price?: true
    coverUrl?: true
    coverDataUri?: true
    sold?: true
    transactionId?: true
    shoppingCartId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookMaxAggregateInputType = {
    id?: true
    title?: true
    publisherId?: true
    publishYear?: true
    isbn?: true
    description?: true
    price?: true
    coverUrl?: true
    coverDataUri?: true
    sold?: true
    transactionId?: true
    shoppingCartId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookCountAggregateInputType = {
    id?: true
    title?: true
    publisherId?: true
    publishYear?: true
    isbn?: true
    description?: true
    price?: true
    coverUrl?: true
    coverDataUri?: true
    sold?: true
    transactionId?: true
    shoppingCartId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookAggregateArgs = {
    /**
     * Filter which Book to aggregate.
    **/
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
    **/
    orderBy?: Enumerable<BookOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Books
    **/
    count?: true | BookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: BookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: BookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: BookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: BookMaxAggregateInputType
  }

  export type GetBookAggregateType<T extends BookAggregateArgs> = {
    [P in keyof T & keyof AggregateBook]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBook[P]>
      : GetScalarType<T[P], AggregateBook[P]>
  }



  export type BookSelect = {
    id?: boolean
    title?: boolean
    authors?: boolean | AuthorFindManyArgs
    publisher?: boolean | PublisherArgs
    publisherId?: boolean
    publishYear?: boolean
    isbn?: boolean
    description?: boolean
    genres?: boolean | GenreFindManyArgs
    price?: boolean
    reviews?: boolean | ReviewFindManyArgs
    coverUrl?: boolean
    coverDataUri?: boolean
    sold?: boolean
    transaction?: boolean | TransactionArgs
    transactionId?: boolean
    shoppingCart?: boolean | ShoppingCartArgs
    shoppingCartId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookInclude = {
    authors?: boolean | AuthorFindManyArgs
    publisher?: boolean | PublisherArgs
    genres?: boolean | GenreFindManyArgs
    reviews?: boolean | ReviewFindManyArgs
    transaction?: boolean | TransactionArgs
    shoppingCart?: boolean | ShoppingCartArgs
  }

  export type BookGetPayload<
    S extends boolean | null | undefined | BookArgs,
    U = keyof S
      > = S extends true
        ? Book
    : S extends undefined
    ? never
    : S extends BookArgs | BookFindManyArgs
    ?'include' extends U
    ? Book  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'authors'
        ? Array < AuthorGetPayload<S['include'][P]>>  :
        P extends 'publisher'
        ? PublisherGetPayload<S['include'][P]> :
        P extends 'genres'
        ? Array < GenreGetPayload<S['include'][P]>>  :
        P extends 'reviews'
        ? Array < ReviewGetPayload<S['include'][P]>>  :
        P extends 'transaction'
        ? TransactionGetPayload<S['include'][P]> | null :
        P extends 'shoppingCart'
        ? ShoppingCartGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Book ?Book [P]
  : 
          P extends 'authors'
        ? Array < AuthorGetPayload<S['select'][P]>>  :
        P extends 'publisher'
        ? PublisherGetPayload<S['select'][P]> :
        P extends 'genres'
        ? Array < GenreGetPayload<S['select'][P]>>  :
        P extends 'reviews'
        ? Array < ReviewGetPayload<S['select'][P]>>  :
        P extends 'transaction'
        ? TransactionGetPayload<S['select'][P]> | null :
        P extends 'shoppingCart'
        ? ShoppingCartGetPayload<S['select'][P]> | null : never
  } 
    : Book
  : Book


  type BookCountArgs = Merge<
    Omit<BookFindManyArgs, 'select' | 'include'> & {
      select?: BookCountAggregateInputType | true
    }
  >

  export interface BookDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Book that matches the filter.
     * @param {BookFindUniqueArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BookFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BookFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Book'> extends True ? CheckSelect<T, Prisma__BookClient<Book>, Prisma__BookClient<BookGetPayload<T>>> : CheckSelect<T, Prisma__BookClient<Book | null >, Prisma__BookClient<BookGetPayload<T> | null >>

    /**
     * Find the first Book that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookFindFirstArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BookFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BookFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Book'> extends True ? CheckSelect<T, Prisma__BookClient<Book>, Prisma__BookClient<BookGetPayload<T>>> : CheckSelect<T, Prisma__BookClient<Book | null >, Prisma__BookClient<BookGetPayload<T> | null >>

    /**
     * Find zero or more Books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Books
     * const books = await prisma.book.findMany()
     * 
     * // Get first 10 Books
     * const books = await prisma.book.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookWithIdOnly = await prisma.book.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BookFindManyArgs>(
      args?: SelectSubset<T, BookFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Book>>, PrismaPromise<Array<BookGetPayload<T>>>>

    /**
     * Create a Book.
     * @param {BookCreateArgs} args - Arguments to create a Book.
     * @example
     * // Create one Book
     * const Book = await prisma.book.create({
     *   data: {
     *     // ... data to create a Book
     *   }
     * })
     * 
    **/
    create<T extends BookCreateArgs>(
      args: SelectSubset<T, BookCreateArgs>
    ): CheckSelect<T, Prisma__BookClient<Book>, Prisma__BookClient<BookGetPayload<T>>>

    /**
     * Delete a Book.
     * @param {BookDeleteArgs} args - Arguments to delete one Book.
     * @example
     * // Delete one Book
     * const Book = await prisma.book.delete({
     *   where: {
     *     // ... filter to delete one Book
     *   }
     * })
     * 
    **/
    delete<T extends BookDeleteArgs>(
      args: SelectSubset<T, BookDeleteArgs>
    ): CheckSelect<T, Prisma__BookClient<Book>, Prisma__BookClient<BookGetPayload<T>>>

    /**
     * Update one Book.
     * @param {BookUpdateArgs} args - Arguments to update one Book.
     * @example
     * // Update one Book
     * const book = await prisma.book.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BookUpdateArgs>(
      args: SelectSubset<T, BookUpdateArgs>
    ): CheckSelect<T, Prisma__BookClient<Book>, Prisma__BookClient<BookGetPayload<T>>>

    /**
     * Delete zero or more Books.
     * @param {BookDeleteManyArgs} args - Arguments to filter Books to delete.
     * @example
     * // Delete a few Books
     * const { count } = await prisma.book.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BookDeleteManyArgs>(
      args?: SelectSubset<T, BookDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Books
     * const book = await prisma.book.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BookUpdateManyArgs>(
      args: SelectSubset<T, BookUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Book.
     * @param {BookUpsertArgs} args - Arguments to update or create a Book.
     * @example
     * // Update or create a Book
     * const book = await prisma.book.upsert({
     *   create: {
     *     // ... data to create a Book
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Book we want to update
     *   }
     * })
    **/
    upsert<T extends BookUpsertArgs>(
      args: SelectSubset<T, BookUpsertArgs>
    ): CheckSelect<T, Prisma__BookClient<Book>, Prisma__BookClient<BookGetPayload<T>>>

    /**
     * Count the number of Books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCountArgs} args - Arguments to filter Books to count.
     * @example
     * // Count the number of Books
     * const count = await prisma.book.count({
     *   where: {
     *     // ... the filter for the Books we want to count
     *   }
     * })
    **/
    count<T extends BookCountArgs>(
      args?: Subset<T, BookCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Book.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookAggregateArgs>(args: Subset<T, BookAggregateArgs>): PrismaPromise<GetBookAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Book.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BookClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    authors<T extends AuthorFindManyArgs = {}>(args?: Subset<T, AuthorFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Author>>, PrismaPromise<Array<AuthorGetPayload<T>>>>;

    publisher<T extends PublisherArgs = {}>(args?: Subset<T, PublisherArgs>): CheckSelect<T, Prisma__PublisherClient<Publisher | null >, Prisma__PublisherClient<PublisherGetPayload<T> | null >>;

    genres<T extends GenreFindManyArgs = {}>(args?: Subset<T, GenreFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Genre>>, PrismaPromise<Array<GenreGetPayload<T>>>>;

    reviews<T extends ReviewFindManyArgs = {}>(args?: Subset<T, ReviewFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Review>>, PrismaPromise<Array<ReviewGetPayload<T>>>>;

    transaction<T extends TransactionArgs = {}>(args?: Subset<T, TransactionArgs>): CheckSelect<T, Prisma__TransactionClient<Transaction | null >, Prisma__TransactionClient<TransactionGetPayload<T> | null >>;

    shoppingCart<T extends ShoppingCartArgs = {}>(args?: Subset<T, ShoppingCartArgs>): CheckSelect<T, Prisma__ShoppingCartClient<ShoppingCart | null >, Prisma__ShoppingCartClient<ShoppingCartGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Book findUnique
   */
  export type BookFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Book
    **/
    select?: BookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: BookInclude | null
    /**
     * Throw an Error if a Book can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Book to fetch.
    **/
    where: BookWhereUniqueInput
  }


  /**
   * Book findFirst
   */
  export type BookFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Book
    **/
    select?: BookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: BookInclude | null
    /**
     * Throw an Error if a Book can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Book to fetch.
    **/
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
    **/
    orderBy?: Enumerable<BookOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Books.
    **/
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Books.
    **/
    distinct?: Enumerable<BookScalarFieldEnum>
  }


  /**
   * Book findMany
   */
  export type BookFindManyArgs = {
    /**
     * Select specific fields to fetch from the Book
    **/
    select?: BookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: BookInclude | null
    /**
     * Filter, which Books to fetch.
    **/
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
    **/
    orderBy?: Enumerable<BookOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Books.
    **/
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
    **/
    skip?: number
    distinct?: Enumerable<BookScalarFieldEnum>
  }


  /**
   * Book create
   */
  export type BookCreateArgs = {
    /**
     * Select specific fields to fetch from the Book
    **/
    select?: BookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: BookInclude | null
    /**
     * The data needed to create a Book.
    **/
    data: XOR<BookCreateInput, BookUncheckedCreateInput>
  }


  /**
   * Book update
   */
  export type BookUpdateArgs = {
    /**
     * Select specific fields to fetch from the Book
    **/
    select?: BookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: BookInclude | null
    /**
     * The data needed to update a Book.
    **/
    data: XOR<BookUpdateInput, BookUncheckedUpdateInput>
    /**
     * Choose, which Book to update.
    **/
    where: BookWhereUniqueInput
  }


  /**
   * Book updateMany
   */
  export type BookUpdateManyArgs = {
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyInput>
    where?: BookWhereInput
  }


  /**
   * Book upsert
   */
  export type BookUpsertArgs = {
    /**
     * Select specific fields to fetch from the Book
    **/
    select?: BookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: BookInclude | null
    /**
     * The filter to search for the Book to update in case it exists.
    **/
    where: BookWhereUniqueInput
    /**
     * In case the Book found by the `where` argument doesn't exist, create a new Book with this data.
    **/
    create: XOR<BookCreateInput, BookUncheckedCreateInput>
    /**
     * In case the Book was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<BookUpdateInput, BookUncheckedUpdateInput>
  }


  /**
   * Book delete
   */
  export type BookDeleteArgs = {
    /**
     * Select specific fields to fetch from the Book
    **/
    select?: BookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: BookInclude | null
    /**
     * Filter which Book to delete.
    **/
    where: BookWhereUniqueInput
  }


  /**
   * Book deleteMany
   */
  export type BookDeleteManyArgs = {
    where?: BookWhereInput
  }


  /**
   * Book without action
   */
  export type BookArgs = {
    /**
     * Select specific fields to fetch from the Book
    **/
    select?: BookSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: BookInclude | null
  }



  /**
   * Model Author
   */


  export type AggregateAuthor = {
    count: AuthorCountAggregateOutputType | null
    min: AuthorMinAggregateOutputType | null
    max: AuthorMaxAggregateOutputType | null
  }

  export type AuthorMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuthorMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuthorCountAggregateOutputType = {
    id: number | null
    firstName: number | null
    middleName: number | null
    lastName: number | null
    description: number | null
    createdAt: number | null
    updatedAt: number | null
    _all: number
  }


  export type AuthorMinAggregateInputType = {
    id?: true
    firstName?: true
    middleName?: true
    lastName?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuthorMaxAggregateInputType = {
    id?: true
    firstName?: true
    middleName?: true
    lastName?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuthorCountAggregateInputType = {
    id?: true
    firstName?: true
    middleName?: true
    lastName?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuthorAggregateArgs = {
    /**
     * Filter which Author to aggregate.
    **/
    where?: AuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
    **/
    orderBy?: Enumerable<AuthorOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: AuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Authors
    **/
    count?: true | AuthorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: AuthorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: AuthorMaxAggregateInputType
  }

  export type GetAuthorAggregateType<T extends AuthorAggregateArgs> = {
    [P in keyof T & keyof AggregateAuthor]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthor[P]>
      : GetScalarType<T[P], AggregateAuthor[P]>
  }



  export type AuthorSelect = {
    id?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    description?: boolean
    books?: boolean | BookFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuthorInclude = {
    books?: boolean | BookFindManyArgs
  }

  export type AuthorGetPayload<
    S extends boolean | null | undefined | AuthorArgs,
    U = keyof S
      > = S extends true
        ? Author
    : S extends undefined
    ? never
    : S extends AuthorArgs | AuthorFindManyArgs
    ?'include' extends U
    ? Author  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'books'
        ? Array < BookGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Author ?Author [P]
  : 
          P extends 'books'
        ? Array < BookGetPayload<S['select'][P]>>  : never
  } 
    : Author
  : Author


  type AuthorCountArgs = Merge<
    Omit<AuthorFindManyArgs, 'select' | 'include'> & {
      select?: AuthorCountAggregateInputType | true
    }
  >

  export interface AuthorDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Author that matches the filter.
     * @param {AuthorFindUniqueArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AuthorFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AuthorFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Author'> extends True ? CheckSelect<T, Prisma__AuthorClient<Author>, Prisma__AuthorClient<AuthorGetPayload<T>>> : CheckSelect<T, Prisma__AuthorClient<Author | null >, Prisma__AuthorClient<AuthorGetPayload<T> | null >>

    /**
     * Find the first Author that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorFindFirstArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AuthorFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AuthorFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Author'> extends True ? CheckSelect<T, Prisma__AuthorClient<Author>, Prisma__AuthorClient<AuthorGetPayload<T>>> : CheckSelect<T, Prisma__AuthorClient<Author | null >, Prisma__AuthorClient<AuthorGetPayload<T> | null >>

    /**
     * Find zero or more Authors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Authors
     * const authors = await prisma.author.findMany()
     * 
     * // Get first 10 Authors
     * const authors = await prisma.author.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authorWithIdOnly = await prisma.author.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AuthorFindManyArgs>(
      args?: SelectSubset<T, AuthorFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Author>>, PrismaPromise<Array<AuthorGetPayload<T>>>>

    /**
     * Create a Author.
     * @param {AuthorCreateArgs} args - Arguments to create a Author.
     * @example
     * // Create one Author
     * const Author = await prisma.author.create({
     *   data: {
     *     // ... data to create a Author
     *   }
     * })
     * 
    **/
    create<T extends AuthorCreateArgs>(
      args: SelectSubset<T, AuthorCreateArgs>
    ): CheckSelect<T, Prisma__AuthorClient<Author>, Prisma__AuthorClient<AuthorGetPayload<T>>>

    /**
     * Delete a Author.
     * @param {AuthorDeleteArgs} args - Arguments to delete one Author.
     * @example
     * // Delete one Author
     * const Author = await prisma.author.delete({
     *   where: {
     *     // ... filter to delete one Author
     *   }
     * })
     * 
    **/
    delete<T extends AuthorDeleteArgs>(
      args: SelectSubset<T, AuthorDeleteArgs>
    ): CheckSelect<T, Prisma__AuthorClient<Author>, Prisma__AuthorClient<AuthorGetPayload<T>>>

    /**
     * Update one Author.
     * @param {AuthorUpdateArgs} args - Arguments to update one Author.
     * @example
     * // Update one Author
     * const author = await prisma.author.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AuthorUpdateArgs>(
      args: SelectSubset<T, AuthorUpdateArgs>
    ): CheckSelect<T, Prisma__AuthorClient<Author>, Prisma__AuthorClient<AuthorGetPayload<T>>>

    /**
     * Delete zero or more Authors.
     * @param {AuthorDeleteManyArgs} args - Arguments to filter Authors to delete.
     * @example
     * // Delete a few Authors
     * const { count } = await prisma.author.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AuthorDeleteManyArgs>(
      args?: SelectSubset<T, AuthorDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Authors
     * const author = await prisma.author.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AuthorUpdateManyArgs>(
      args: SelectSubset<T, AuthorUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Author.
     * @param {AuthorUpsertArgs} args - Arguments to update or create a Author.
     * @example
     * // Update or create a Author
     * const author = await prisma.author.upsert({
     *   create: {
     *     // ... data to create a Author
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Author we want to update
     *   }
     * })
    **/
    upsert<T extends AuthorUpsertArgs>(
      args: SelectSubset<T, AuthorUpsertArgs>
    ): CheckSelect<T, Prisma__AuthorClient<Author>, Prisma__AuthorClient<AuthorGetPayload<T>>>

    /**
     * Count the number of Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorCountArgs} args - Arguments to filter Authors to count.
     * @example
     * // Count the number of Authors
     * const count = await prisma.author.count({
     *   where: {
     *     // ... the filter for the Authors we want to count
     *   }
     * })
    **/
    count<T extends AuthorCountArgs>(
      args?: Subset<T, AuthorCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Author.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthorAggregateArgs>(args: Subset<T, AuthorAggregateArgs>): PrismaPromise<GetAuthorAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Author.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AuthorClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    books<T extends BookFindManyArgs = {}>(args?: Subset<T, BookFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Book>>, PrismaPromise<Array<BookGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Author findUnique
   */
  export type AuthorFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Author
    **/
    select?: AuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AuthorInclude | null
    /**
     * Throw an Error if a Author can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Author to fetch.
    **/
    where: AuthorWhereUniqueInput
  }


  /**
   * Author findFirst
   */
  export type AuthorFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Author
    **/
    select?: AuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AuthorInclude | null
    /**
     * Throw an Error if a Author can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Author to fetch.
    **/
    where?: AuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
    **/
    orderBy?: Enumerable<AuthorOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Authors.
    **/
    cursor?: AuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Authors.
    **/
    distinct?: Enumerable<AuthorScalarFieldEnum>
  }


  /**
   * Author findMany
   */
  export type AuthorFindManyArgs = {
    /**
     * Select specific fields to fetch from the Author
    **/
    select?: AuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AuthorInclude | null
    /**
     * Filter, which Authors to fetch.
    **/
    where?: AuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
    **/
    orderBy?: Enumerable<AuthorOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Authors.
    **/
    cursor?: AuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
    **/
    skip?: number
    distinct?: Enumerable<AuthorScalarFieldEnum>
  }


  /**
   * Author create
   */
  export type AuthorCreateArgs = {
    /**
     * Select specific fields to fetch from the Author
    **/
    select?: AuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AuthorInclude | null
    /**
     * The data needed to create a Author.
    **/
    data: XOR<AuthorCreateInput, AuthorUncheckedCreateInput>
  }


  /**
   * Author update
   */
  export type AuthorUpdateArgs = {
    /**
     * Select specific fields to fetch from the Author
    **/
    select?: AuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AuthorInclude | null
    /**
     * The data needed to update a Author.
    **/
    data: XOR<AuthorUpdateInput, AuthorUncheckedUpdateInput>
    /**
     * Choose, which Author to update.
    **/
    where: AuthorWhereUniqueInput
  }


  /**
   * Author updateMany
   */
  export type AuthorUpdateManyArgs = {
    data: XOR<AuthorUpdateManyMutationInput, AuthorUncheckedUpdateManyInput>
    where?: AuthorWhereInput
  }


  /**
   * Author upsert
   */
  export type AuthorUpsertArgs = {
    /**
     * Select specific fields to fetch from the Author
    **/
    select?: AuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AuthorInclude | null
    /**
     * The filter to search for the Author to update in case it exists.
    **/
    where: AuthorWhereUniqueInput
    /**
     * In case the Author found by the `where` argument doesn't exist, create a new Author with this data.
    **/
    create: XOR<AuthorCreateInput, AuthorUncheckedCreateInput>
    /**
     * In case the Author was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<AuthorUpdateInput, AuthorUncheckedUpdateInput>
  }


  /**
   * Author delete
   */
  export type AuthorDeleteArgs = {
    /**
     * Select specific fields to fetch from the Author
    **/
    select?: AuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AuthorInclude | null
    /**
     * Filter which Author to delete.
    **/
    where: AuthorWhereUniqueInput
  }


  /**
   * Author deleteMany
   */
  export type AuthorDeleteManyArgs = {
    where?: AuthorWhereInput
  }


  /**
   * Author without action
   */
  export type AuthorArgs = {
    /**
     * Select specific fields to fetch from the Author
    **/
    select?: AuthorSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AuthorInclude | null
  }



  /**
   * Model Publisher
   */


  export type AggregatePublisher = {
    count: PublisherCountAggregateOutputType | null
    min: PublisherMinAggregateOutputType | null
    max: PublisherMaxAggregateOutputType | null
  }

  export type PublisherMinAggregateOutputType = {
    id: string | null
    name: string | null
    city: string | null
    state: string | null
    website: string | null
  }

  export type PublisherMaxAggregateOutputType = {
    id: string | null
    name: string | null
    city: string | null
    state: string | null
    website: string | null
  }

  export type PublisherCountAggregateOutputType = {
    id: number | null
    name: number | null
    city: number | null
    state: number | null
    website: number | null
    _all: number
  }


  export type PublisherMinAggregateInputType = {
    id?: true
    name?: true
    city?: true
    state?: true
    website?: true
  }

  export type PublisherMaxAggregateInputType = {
    id?: true
    name?: true
    city?: true
    state?: true
    website?: true
  }

  export type PublisherCountAggregateInputType = {
    id?: true
    name?: true
    city?: true
    state?: true
    website?: true
    _all?: true
  }

  export type PublisherAggregateArgs = {
    /**
     * Filter which Publisher to aggregate.
    **/
    where?: PublisherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publishers to fetch.
    **/
    orderBy?: Enumerable<PublisherOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: PublisherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publishers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publishers.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Publishers
    **/
    count?: true | PublisherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: PublisherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: PublisherMaxAggregateInputType
  }

  export type GetPublisherAggregateType<T extends PublisherAggregateArgs> = {
    [P in keyof T & keyof AggregatePublisher]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublisher[P]>
      : GetScalarType<T[P], AggregatePublisher[P]>
  }



  export type PublisherSelect = {
    id?: boolean
    name?: boolean
    city?: boolean
    state?: boolean
    website?: boolean
    book?: boolean | BookFindManyArgs
  }

  export type PublisherInclude = {
    book?: boolean | BookFindManyArgs
  }

  export type PublisherGetPayload<
    S extends boolean | null | undefined | PublisherArgs,
    U = keyof S
      > = S extends true
        ? Publisher
    : S extends undefined
    ? never
    : S extends PublisherArgs | PublisherFindManyArgs
    ?'include' extends U
    ? Publisher  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'book'
        ? Array < BookGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Publisher ?Publisher [P]
  : 
          P extends 'book'
        ? Array < BookGetPayload<S['select'][P]>>  : never
  } 
    : Publisher
  : Publisher


  type PublisherCountArgs = Merge<
    Omit<PublisherFindManyArgs, 'select' | 'include'> & {
      select?: PublisherCountAggregateInputType | true
    }
  >

  export interface PublisherDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Publisher that matches the filter.
     * @param {PublisherFindUniqueArgs} args - Arguments to find a Publisher
     * @example
     * // Get one Publisher
     * const publisher = await prisma.publisher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PublisherFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PublisherFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Publisher'> extends True ? CheckSelect<T, Prisma__PublisherClient<Publisher>, Prisma__PublisherClient<PublisherGetPayload<T>>> : CheckSelect<T, Prisma__PublisherClient<Publisher | null >, Prisma__PublisherClient<PublisherGetPayload<T> | null >>

    /**
     * Find the first Publisher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublisherFindFirstArgs} args - Arguments to find a Publisher
     * @example
     * // Get one Publisher
     * const publisher = await prisma.publisher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PublisherFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PublisherFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Publisher'> extends True ? CheckSelect<T, Prisma__PublisherClient<Publisher>, Prisma__PublisherClient<PublisherGetPayload<T>>> : CheckSelect<T, Prisma__PublisherClient<Publisher | null >, Prisma__PublisherClient<PublisherGetPayload<T> | null >>

    /**
     * Find zero or more Publishers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublisherFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Publishers
     * const publishers = await prisma.publisher.findMany()
     * 
     * // Get first 10 Publishers
     * const publishers = await prisma.publisher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const publisherWithIdOnly = await prisma.publisher.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PublisherFindManyArgs>(
      args?: SelectSubset<T, PublisherFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Publisher>>, PrismaPromise<Array<PublisherGetPayload<T>>>>

    /**
     * Create a Publisher.
     * @param {PublisherCreateArgs} args - Arguments to create a Publisher.
     * @example
     * // Create one Publisher
     * const Publisher = await prisma.publisher.create({
     *   data: {
     *     // ... data to create a Publisher
     *   }
     * })
     * 
    **/
    create<T extends PublisherCreateArgs>(
      args: SelectSubset<T, PublisherCreateArgs>
    ): CheckSelect<T, Prisma__PublisherClient<Publisher>, Prisma__PublisherClient<PublisherGetPayload<T>>>

    /**
     * Delete a Publisher.
     * @param {PublisherDeleteArgs} args - Arguments to delete one Publisher.
     * @example
     * // Delete one Publisher
     * const Publisher = await prisma.publisher.delete({
     *   where: {
     *     // ... filter to delete one Publisher
     *   }
     * })
     * 
    **/
    delete<T extends PublisherDeleteArgs>(
      args: SelectSubset<T, PublisherDeleteArgs>
    ): CheckSelect<T, Prisma__PublisherClient<Publisher>, Prisma__PublisherClient<PublisherGetPayload<T>>>

    /**
     * Update one Publisher.
     * @param {PublisherUpdateArgs} args - Arguments to update one Publisher.
     * @example
     * // Update one Publisher
     * const publisher = await prisma.publisher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PublisherUpdateArgs>(
      args: SelectSubset<T, PublisherUpdateArgs>
    ): CheckSelect<T, Prisma__PublisherClient<Publisher>, Prisma__PublisherClient<PublisherGetPayload<T>>>

    /**
     * Delete zero or more Publishers.
     * @param {PublisherDeleteManyArgs} args - Arguments to filter Publishers to delete.
     * @example
     * // Delete a few Publishers
     * const { count } = await prisma.publisher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PublisherDeleteManyArgs>(
      args?: SelectSubset<T, PublisherDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publishers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublisherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Publishers
     * const publisher = await prisma.publisher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PublisherUpdateManyArgs>(
      args: SelectSubset<T, PublisherUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Publisher.
     * @param {PublisherUpsertArgs} args - Arguments to update or create a Publisher.
     * @example
     * // Update or create a Publisher
     * const publisher = await prisma.publisher.upsert({
     *   create: {
     *     // ... data to create a Publisher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Publisher we want to update
     *   }
     * })
    **/
    upsert<T extends PublisherUpsertArgs>(
      args: SelectSubset<T, PublisherUpsertArgs>
    ): CheckSelect<T, Prisma__PublisherClient<Publisher>, Prisma__PublisherClient<PublisherGetPayload<T>>>

    /**
     * Count the number of Publishers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublisherCountArgs} args - Arguments to filter Publishers to count.
     * @example
     * // Count the number of Publishers
     * const count = await prisma.publisher.count({
     *   where: {
     *     // ... the filter for the Publishers we want to count
     *   }
     * })
    **/
    count<T extends PublisherCountArgs>(
      args?: Subset<T, PublisherCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PublisherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Publisher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublisherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PublisherAggregateArgs>(args: Subset<T, PublisherAggregateArgs>): PrismaPromise<GetPublisherAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Publisher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PublisherClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    book<T extends BookFindManyArgs = {}>(args?: Subset<T, BookFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Book>>, PrismaPromise<Array<BookGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Publisher findUnique
   */
  export type PublisherFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Publisher
    **/
    select?: PublisherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PublisherInclude | null
    /**
     * Throw an Error if a Publisher can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Publisher to fetch.
    **/
    where: PublisherWhereUniqueInput
  }


  /**
   * Publisher findFirst
   */
  export type PublisherFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Publisher
    **/
    select?: PublisherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PublisherInclude | null
    /**
     * Throw an Error if a Publisher can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Publisher to fetch.
    **/
    where?: PublisherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publishers to fetch.
    **/
    orderBy?: Enumerable<PublisherOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Publishers.
    **/
    cursor?: PublisherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publishers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publishers.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Publishers.
    **/
    distinct?: Enumerable<PublisherScalarFieldEnum>
  }


  /**
   * Publisher findMany
   */
  export type PublisherFindManyArgs = {
    /**
     * Select specific fields to fetch from the Publisher
    **/
    select?: PublisherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PublisherInclude | null
    /**
     * Filter, which Publishers to fetch.
    **/
    where?: PublisherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publishers to fetch.
    **/
    orderBy?: Enumerable<PublisherOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Publishers.
    **/
    cursor?: PublisherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publishers from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publishers.
    **/
    skip?: number
    distinct?: Enumerable<PublisherScalarFieldEnum>
  }


  /**
   * Publisher create
   */
  export type PublisherCreateArgs = {
    /**
     * Select specific fields to fetch from the Publisher
    **/
    select?: PublisherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PublisherInclude | null
    /**
     * The data needed to create a Publisher.
    **/
    data: XOR<PublisherCreateInput, PublisherUncheckedCreateInput>
  }


  /**
   * Publisher update
   */
  export type PublisherUpdateArgs = {
    /**
     * Select specific fields to fetch from the Publisher
    **/
    select?: PublisherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PublisherInclude | null
    /**
     * The data needed to update a Publisher.
    **/
    data: XOR<PublisherUpdateInput, PublisherUncheckedUpdateInput>
    /**
     * Choose, which Publisher to update.
    **/
    where: PublisherWhereUniqueInput
  }


  /**
   * Publisher updateMany
   */
  export type PublisherUpdateManyArgs = {
    data: XOR<PublisherUpdateManyMutationInput, PublisherUncheckedUpdateManyInput>
    where?: PublisherWhereInput
  }


  /**
   * Publisher upsert
   */
  export type PublisherUpsertArgs = {
    /**
     * Select specific fields to fetch from the Publisher
    **/
    select?: PublisherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PublisherInclude | null
    /**
     * The filter to search for the Publisher to update in case it exists.
    **/
    where: PublisherWhereUniqueInput
    /**
     * In case the Publisher found by the `where` argument doesn't exist, create a new Publisher with this data.
    **/
    create: XOR<PublisherCreateInput, PublisherUncheckedCreateInput>
    /**
     * In case the Publisher was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<PublisherUpdateInput, PublisherUncheckedUpdateInput>
  }


  /**
   * Publisher delete
   */
  export type PublisherDeleteArgs = {
    /**
     * Select specific fields to fetch from the Publisher
    **/
    select?: PublisherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PublisherInclude | null
    /**
     * Filter which Publisher to delete.
    **/
    where: PublisherWhereUniqueInput
  }


  /**
   * Publisher deleteMany
   */
  export type PublisherDeleteManyArgs = {
    where?: PublisherWhereInput
  }


  /**
   * Publisher without action
   */
  export type PublisherArgs = {
    /**
     * Select specific fields to fetch from the Publisher
    **/
    select?: PublisherSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PublisherInclude | null
  }



  /**
   * Model Genre
   */


  export type AggregateGenre = {
    count: GenreCountAggregateOutputType | null
    avg: GenreAvgAggregateOutputType | null
    sum: GenreSumAggregateOutputType | null
    min: GenreMinAggregateOutputType | null
    max: GenreMaxAggregateOutputType | null
  }

  export type GenreAvgAggregateOutputType = {
    id: number
  }

  export type GenreSumAggregateOutputType = {
    id: number
  }

  export type GenreMinAggregateOutputType = {
    id: number
    name: string | null
  }

  export type GenreMaxAggregateOutputType = {
    id: number
    name: string | null
  }

  export type GenreCountAggregateOutputType = {
    id: number
    name: number | null
    _all: number
  }


  export type GenreAvgAggregateInputType = {
    id?: true
  }

  export type GenreSumAggregateInputType = {
    id?: true
  }

  export type GenreMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type GenreMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type GenreCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type GenreAggregateArgs = {
    /**
     * Filter which Genre to aggregate.
    **/
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
    **/
    orderBy?: Enumerable<GenreOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Genres
    **/
    count?: true | GenreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: GenreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: GenreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: GenreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: GenreMaxAggregateInputType
  }

  export type GetGenreAggregateType<T extends GenreAggregateArgs> = {
    [P in keyof T & keyof AggregateGenre]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGenre[P]>
      : GetScalarType<T[P], AggregateGenre[P]>
  }



  export type GenreSelect = {
    id?: boolean
    name?: boolean
    books?: boolean | BookFindManyArgs
  }

  export type GenreInclude = {
    books?: boolean | BookFindManyArgs
  }

  export type GenreGetPayload<
    S extends boolean | null | undefined | GenreArgs,
    U = keyof S
      > = S extends true
        ? Genre
    : S extends undefined
    ? never
    : S extends GenreArgs | GenreFindManyArgs
    ?'include' extends U
    ? Genre  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'books'
        ? Array < BookGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Genre ?Genre [P]
  : 
          P extends 'books'
        ? Array < BookGetPayload<S['select'][P]>>  : never
  } 
    : Genre
  : Genre


  type GenreCountArgs = Merge<
    Omit<GenreFindManyArgs, 'select' | 'include'> & {
      select?: GenreCountAggregateInputType | true
    }
  >

  export interface GenreDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Genre that matches the filter.
     * @param {GenreFindUniqueArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GenreFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, GenreFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Genre'> extends True ? CheckSelect<T, Prisma__GenreClient<Genre>, Prisma__GenreClient<GenreGetPayload<T>>> : CheckSelect<T, Prisma__GenreClient<Genre | null >, Prisma__GenreClient<GenreGetPayload<T> | null >>

    /**
     * Find the first Genre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindFirstArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GenreFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, GenreFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Genre'> extends True ? CheckSelect<T, Prisma__GenreClient<Genre>, Prisma__GenreClient<GenreGetPayload<T>>> : CheckSelect<T, Prisma__GenreClient<Genre | null >, Prisma__GenreClient<GenreGetPayload<T> | null >>

    /**
     * Find zero or more Genres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Genres
     * const genres = await prisma.genre.findMany()
     * 
     * // Get first 10 Genres
     * const genres = await prisma.genre.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const genreWithIdOnly = await prisma.genre.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GenreFindManyArgs>(
      args?: SelectSubset<T, GenreFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Genre>>, PrismaPromise<Array<GenreGetPayload<T>>>>

    /**
     * Create a Genre.
     * @param {GenreCreateArgs} args - Arguments to create a Genre.
     * @example
     * // Create one Genre
     * const Genre = await prisma.genre.create({
     *   data: {
     *     // ... data to create a Genre
     *   }
     * })
     * 
    **/
    create<T extends GenreCreateArgs>(
      args: SelectSubset<T, GenreCreateArgs>
    ): CheckSelect<T, Prisma__GenreClient<Genre>, Prisma__GenreClient<GenreGetPayload<T>>>

    /**
     * Delete a Genre.
     * @param {GenreDeleteArgs} args - Arguments to delete one Genre.
     * @example
     * // Delete one Genre
     * const Genre = await prisma.genre.delete({
     *   where: {
     *     // ... filter to delete one Genre
     *   }
     * })
     * 
    **/
    delete<T extends GenreDeleteArgs>(
      args: SelectSubset<T, GenreDeleteArgs>
    ): CheckSelect<T, Prisma__GenreClient<Genre>, Prisma__GenreClient<GenreGetPayload<T>>>

    /**
     * Update one Genre.
     * @param {GenreUpdateArgs} args - Arguments to update one Genre.
     * @example
     * // Update one Genre
     * const genre = await prisma.genre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GenreUpdateArgs>(
      args: SelectSubset<T, GenreUpdateArgs>
    ): CheckSelect<T, Prisma__GenreClient<Genre>, Prisma__GenreClient<GenreGetPayload<T>>>

    /**
     * Delete zero or more Genres.
     * @param {GenreDeleteManyArgs} args - Arguments to filter Genres to delete.
     * @example
     * // Delete a few Genres
     * const { count } = await prisma.genre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GenreDeleteManyArgs>(
      args?: SelectSubset<T, GenreDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Genres
     * const genre = await prisma.genre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GenreUpdateManyArgs>(
      args: SelectSubset<T, GenreUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Genre.
     * @param {GenreUpsertArgs} args - Arguments to update or create a Genre.
     * @example
     * // Update or create a Genre
     * const genre = await prisma.genre.upsert({
     *   create: {
     *     // ... data to create a Genre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Genre we want to update
     *   }
     * })
    **/
    upsert<T extends GenreUpsertArgs>(
      args: SelectSubset<T, GenreUpsertArgs>
    ): CheckSelect<T, Prisma__GenreClient<Genre>, Prisma__GenreClient<GenreGetPayload<T>>>

    /**
     * Count the number of Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreCountArgs} args - Arguments to filter Genres to count.
     * @example
     * // Count the number of Genres
     * const count = await prisma.genre.count({
     *   where: {
     *     // ... the filter for the Genres we want to count
     *   }
     * })
    **/
    count<T extends GenreCountArgs>(
      args?: Subset<T, GenreCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Genre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenreAggregateArgs>(args: Subset<T, GenreAggregateArgs>): PrismaPromise<GetGenreAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Genre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__GenreClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    books<T extends BookFindManyArgs = {}>(args?: Subset<T, BookFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Book>>, PrismaPromise<Array<BookGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Genre findUnique
   */
  export type GenreFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Genre
    **/
    select?: GenreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GenreInclude | null
    /**
     * Throw an Error if a Genre can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Genre to fetch.
    **/
    where: GenreWhereUniqueInput
  }


  /**
   * Genre findFirst
   */
  export type GenreFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Genre
    **/
    select?: GenreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GenreInclude | null
    /**
     * Throw an Error if a Genre can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Genre to fetch.
    **/
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
    **/
    orderBy?: Enumerable<GenreOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genres.
    **/
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genres.
    **/
    distinct?: Enumerable<GenreScalarFieldEnum>
  }


  /**
   * Genre findMany
   */
  export type GenreFindManyArgs = {
    /**
     * Select specific fields to fetch from the Genre
    **/
    select?: GenreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GenreInclude | null
    /**
     * Filter, which Genres to fetch.
    **/
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
    **/
    orderBy?: Enumerable<GenreOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Genres.
    **/
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
    **/
    skip?: number
    distinct?: Enumerable<GenreScalarFieldEnum>
  }


  /**
   * Genre create
   */
  export type GenreCreateArgs = {
    /**
     * Select specific fields to fetch from the Genre
    **/
    select?: GenreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GenreInclude | null
    /**
     * The data needed to create a Genre.
    **/
    data: XOR<GenreCreateInput, GenreUncheckedCreateInput>
  }


  /**
   * Genre update
   */
  export type GenreUpdateArgs = {
    /**
     * Select specific fields to fetch from the Genre
    **/
    select?: GenreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GenreInclude | null
    /**
     * The data needed to update a Genre.
    **/
    data: XOR<GenreUpdateInput, GenreUncheckedUpdateInput>
    /**
     * Choose, which Genre to update.
    **/
    where: GenreWhereUniqueInput
  }


  /**
   * Genre updateMany
   */
  export type GenreUpdateManyArgs = {
    data: XOR<GenreUpdateManyMutationInput, GenreUncheckedUpdateManyInput>
    where?: GenreWhereInput
  }


  /**
   * Genre upsert
   */
  export type GenreUpsertArgs = {
    /**
     * Select specific fields to fetch from the Genre
    **/
    select?: GenreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GenreInclude | null
    /**
     * The filter to search for the Genre to update in case it exists.
    **/
    where: GenreWhereUniqueInput
    /**
     * In case the Genre found by the `where` argument doesn't exist, create a new Genre with this data.
    **/
    create: XOR<GenreCreateInput, GenreUncheckedCreateInput>
    /**
     * In case the Genre was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<GenreUpdateInput, GenreUncheckedUpdateInput>
  }


  /**
   * Genre delete
   */
  export type GenreDeleteArgs = {
    /**
     * Select specific fields to fetch from the Genre
    **/
    select?: GenreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GenreInclude | null
    /**
     * Filter which Genre to delete.
    **/
    where: GenreWhereUniqueInput
  }


  /**
   * Genre deleteMany
   */
  export type GenreDeleteManyArgs = {
    where?: GenreWhereInput
  }


  /**
   * Genre without action
   */
  export type GenreArgs = {
    /**
     * Select specific fields to fetch from the Genre
    **/
    select?: GenreSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: GenreInclude | null
  }



  /**
   * Model Review
   */


  export type AggregateReview = {
    count: ReviewCountAggregateOutputType | null
    avg: ReviewAvgAggregateOutputType | null
    sum: ReviewSumAggregateOutputType | null
    min: ReviewMinAggregateOutputType | null
    max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    value: number
  }

  export type ReviewSumAggregateOutputType = {
    value: number
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    value: number
    description: string | null
    postedAs: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    bookId: string | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    value: number
    description: string | null
    postedAs: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    bookId: string | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number | null
    value: number
    description: number | null
    postedAs: number | null
    createdAt: number | null
    updatedAt: number | null
    userId: number | null
    bookId: number | null
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    value?: true
  }

  export type ReviewSumAggregateInputType = {
    value?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    value?: true
    description?: true
    postedAs?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    bookId?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    value?: true
    description?: true
    postedAs?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    bookId?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    value?: true
    description?: true
    postedAs?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    bookId?: true
    _all?: true
  }

  export type ReviewAggregateArgs = {
    /**
     * Filter which Review to aggregate.
    **/
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
    **/
    orderBy?: Enumerable<ReviewOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
    [P in keyof T & keyof AggregateReview]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }



  export type ReviewSelect = {
    id?: boolean
    value?: boolean
    description?: boolean
    postedAs?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    book?: boolean | BookArgs
    bookId?: boolean
  }

  export type ReviewInclude = {
    user?: boolean | UserArgs
    book?: boolean | BookArgs
  }

  export type ReviewGetPayload<
    S extends boolean | null | undefined | ReviewArgs,
    U = keyof S
      > = S extends true
        ? Review
    : S extends undefined
    ? never
    : S extends ReviewArgs | ReviewFindManyArgs
    ?'include' extends U
    ? Review  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'book'
        ? BookGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Review ?Review [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'book'
        ? BookGetPayload<S['select'][P]> : never
  } 
    : Review
  : Review


  type ReviewCountArgs = Merge<
    Omit<ReviewFindManyArgs, 'select' | 'include'> & {
      select?: ReviewCountAggregateInputType | true
    }
  >

  export interface ReviewDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReviewFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReviewFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Review'> extends True ? CheckSelect<T, Prisma__ReviewClient<Review>, Prisma__ReviewClient<ReviewGetPayload<T>>> : CheckSelect<T, Prisma__ReviewClient<Review | null >, Prisma__ReviewClient<ReviewGetPayload<T> | null >>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReviewFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReviewFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Review'> extends True ? CheckSelect<T, Prisma__ReviewClient<Review>, Prisma__ReviewClient<ReviewGetPayload<T>>> : CheckSelect<T, Prisma__ReviewClient<Review | null >, Prisma__ReviewClient<ReviewGetPayload<T> | null >>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReviewFindManyArgs>(
      args?: SelectSubset<T, ReviewFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Review>>, PrismaPromise<Array<ReviewGetPayload<T>>>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
    **/
    create<T extends ReviewCreateArgs>(
      args: SelectSubset<T, ReviewCreateArgs>
    ): CheckSelect<T, Prisma__ReviewClient<Review>, Prisma__ReviewClient<ReviewGetPayload<T>>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
    **/
    delete<T extends ReviewDeleteArgs>(
      args: SelectSubset<T, ReviewDeleteArgs>
    ): CheckSelect<T, Prisma__ReviewClient<Review>, Prisma__ReviewClient<ReviewGetPayload<T>>>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReviewUpdateArgs>(
      args: SelectSubset<T, ReviewUpdateArgs>
    ): CheckSelect<T, Prisma__ReviewClient<Review>, Prisma__ReviewClient<ReviewGetPayload<T>>>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReviewDeleteManyArgs>(
      args?: SelectSubset<T, ReviewDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReviewUpdateManyArgs>(
      args: SelectSubset<T, ReviewUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
    **/
    upsert<T extends ReviewUpsertArgs>(
      args: SelectSubset<T, ReviewUpsertArgs>
    ): CheckSelect<T, Prisma__ReviewClient<Review>, Prisma__ReviewClient<ReviewGetPayload<T>>>

    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): PrismaPromise<GetReviewAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReviewClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    book<T extends BookArgs = {}>(args?: Subset<T, BookArgs>): CheckSelect<T, Prisma__BookClient<Book | null >, Prisma__BookClient<BookGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Review
    **/
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReviewInclude | null
    /**
     * Throw an Error if a Review can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Review to fetch.
    **/
    where: ReviewWhereUniqueInput
  }


  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Review
    **/
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReviewInclude | null
    /**
     * Throw an Error if a Review can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Review to fetch.
    **/
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
    **/
    orderBy?: Enumerable<ReviewOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
    **/
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
    **/
    distinct?: Enumerable<ReviewScalarFieldEnum>
  }


  /**
   * Review findMany
   */
  export type ReviewFindManyArgs = {
    /**
     * Select specific fields to fetch from the Review
    **/
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReviewInclude | null
    /**
     * Filter, which Reviews to fetch.
    **/
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
    **/
    orderBy?: Enumerable<ReviewOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
    **/
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
    **/
    skip?: number
    distinct?: Enumerable<ReviewScalarFieldEnum>
  }


  /**
   * Review create
   */
  export type ReviewCreateArgs = {
    /**
     * Select specific fields to fetch from the Review
    **/
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReviewInclude | null
    /**
     * The data needed to create a Review.
    **/
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }


  /**
   * Review update
   */
  export type ReviewUpdateArgs = {
    /**
     * Select specific fields to fetch from the Review
    **/
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReviewInclude | null
    /**
     * The data needed to update a Review.
    **/
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
    **/
    where: ReviewWhereUniqueInput
  }


  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs = {
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    where?: ReviewWhereInput
  }


  /**
   * Review upsert
   */
  export type ReviewUpsertArgs = {
    /**
     * Select specific fields to fetch from the Review
    **/
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReviewInclude | null
    /**
     * The filter to search for the Review to update in case it exists.
    **/
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
    **/
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }


  /**
   * Review delete
   */
  export type ReviewDeleteArgs = {
    /**
     * Select specific fields to fetch from the Review
    **/
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReviewInclude | null
    /**
     * Filter which Review to delete.
    **/
    where: ReviewWhereUniqueInput
  }


  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs = {
    where?: ReviewWhereInput
  }


  /**
   * Review without action
   */
  export type ReviewArgs = {
    /**
     * Select specific fields to fetch from the Review
    **/
    select?: ReviewSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ReviewInclude | null
  }



  /**
   * Model Address
   */


  export type AggregateAddress = {
    count: AddressCountAggregateOutputType | null
    min: AddressMinAggregateOutputType | null
    max: AddressMaxAggregateOutputType | null
  }

  export type AddressMinAggregateOutputType = {
    id: string | null
    street: string | null
    apartmentOrUnit: string | null
    city: string | null
    state: string | null
    country: string | null
    zipcode: string | null
    userShippingAddressId: string | null
  }

  export type AddressMaxAggregateOutputType = {
    id: string | null
    street: string | null
    apartmentOrUnit: string | null
    city: string | null
    state: string | null
    country: string | null
    zipcode: string | null
    userShippingAddressId: string | null
  }

  export type AddressCountAggregateOutputType = {
    id: number | null
    street: number | null
    apartmentOrUnit: number | null
    city: number | null
    state: number | null
    country: number | null
    zipcode: number | null
    userShippingAddressId: number | null
    _all: number
  }


  export type AddressMinAggregateInputType = {
    id?: true
    street?: true
    apartmentOrUnit?: true
    city?: true
    state?: true
    country?: true
    zipcode?: true
    userShippingAddressId?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    street?: true
    apartmentOrUnit?: true
    city?: true
    state?: true
    country?: true
    zipcode?: true
    userShippingAddressId?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    street?: true
    apartmentOrUnit?: true
    city?: true
    state?: true
    country?: true
    zipcode?: true
    userShippingAddressId?: true
    _all?: true
  }

  export type AddressAggregateArgs = {
    /**
     * Filter which Address to aggregate.
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
    **/
    orderBy?: Enumerable<AddressOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
    [P in keyof T & keyof AggregateAddress]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }



  export type AddressSelect = {
    id?: boolean
    street?: boolean
    apartmentOrUnit?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    zipcode?: boolean
    userShippingAddress?: boolean | UserArgs
    userShippingAddressId?: boolean
  }

  export type AddressInclude = {
    userShippingAddress?: boolean | UserArgs
  }

  export type AddressGetPayload<
    S extends boolean | null | undefined | AddressArgs,
    U = keyof S
      > = S extends true
        ? Address
    : S extends undefined
    ? never
    : S extends AddressArgs | AddressFindManyArgs
    ?'include' extends U
    ? Address  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'userShippingAddress'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Address ?Address [P]
  : 
          P extends 'userShippingAddress'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : Address
  : Address


  type AddressCountArgs = Merge<
    Omit<AddressFindManyArgs, 'select' | 'include'> & {
      select?: AddressCountAggregateInputType | true
    }
  >

  export interface AddressDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AddressFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AddressFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Address'> extends True ? CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>> : CheckSelect<T, Prisma__AddressClient<Address | null >, Prisma__AddressClient<AddressGetPayload<T> | null >>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AddressFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AddressFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Address'> extends True ? CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>> : CheckSelect<T, Prisma__AddressClient<Address | null >, Prisma__AddressClient<AddressGetPayload<T> | null >>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AddressFindManyArgs>(
      args?: SelectSubset<T, AddressFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Address>>, PrismaPromise<Array<AddressGetPayload<T>>>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
    **/
    create<T extends AddressCreateArgs>(
      args: SelectSubset<T, AddressCreateArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
    **/
    delete<T extends AddressDeleteArgs>(
      args: SelectSubset<T, AddressDeleteArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AddressUpdateArgs>(
      args: SelectSubset<T, AddressUpdateArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AddressDeleteManyArgs>(
      args?: SelectSubset<T, AddressDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AddressUpdateManyArgs>(
      args: SelectSubset<T, AddressUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
    **/
    upsert<T extends AddressUpsertArgs>(
      args: SelectSubset<T, AddressUpsertArgs>
    ): CheckSelect<T, Prisma__AddressClient<Address>, Prisma__AddressClient<AddressGetPayload<T>>>

    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): PrismaPromise<GetAddressAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AddressClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    userShippingAddress<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Address
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AddressInclude | null
    /**
     * Throw an Error if a Address can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Address to fetch.
    **/
    where: AddressWhereUniqueInput
  }


  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Address
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AddressInclude | null
    /**
     * Throw an Error if a Address can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Address to fetch.
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
    **/
    orderBy?: Enumerable<AddressOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
    **/
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * Address findMany
   */
  export type AddressFindManyArgs = {
    /**
     * Select specific fields to fetch from the Address
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AddressInclude | null
    /**
     * Filter, which Addresses to fetch.
    **/
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
    **/
    orderBy?: Enumerable<AddressOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
    **/
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
    **/
    skip?: number
    distinct?: Enumerable<AddressScalarFieldEnum>
  }


  /**
   * Address create
   */
  export type AddressCreateArgs = {
    /**
     * Select specific fields to fetch from the Address
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AddressInclude | null
    /**
     * The data needed to create a Address.
    **/
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }


  /**
   * Address update
   */
  export type AddressUpdateArgs = {
    /**
     * Select specific fields to fetch from the Address
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AddressInclude | null
    /**
     * The data needed to update a Address.
    **/
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
    **/
    where: AddressWhereUniqueInput
  }


  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs = {
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    where?: AddressWhereInput
  }


  /**
   * Address upsert
   */
  export type AddressUpsertArgs = {
    /**
     * Select specific fields to fetch from the Address
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AddressInclude | null
    /**
     * The filter to search for the Address to update in case it exists.
    **/
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
    **/
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }


  /**
   * Address delete
   */
  export type AddressDeleteArgs = {
    /**
     * Select specific fields to fetch from the Address
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AddressInclude | null
    /**
     * Filter which Address to delete.
    **/
    where: AddressWhereUniqueInput
  }


  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs = {
    where?: AddressWhereInput
  }


  /**
   * Address without action
   */
  export type AddressArgs = {
    /**
     * Select specific fields to fetch from the Address
    **/
    select?: AddressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: AddressInclude | null
  }



  /**
   * Model Transaction
   */


  export type AggregateTransaction = {
    count: TransactionCountAggregateOutputType | null
    min: TransactionMinAggregateOutputType | null
    max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number | null
    userId: number | null
    createdAt: number | null
    updatedAt: number | null
    _all: number
  }


  export type TransactionMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionAggregateArgs = {
    /**
     * Filter which Transaction to aggregate.
    **/
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
    **/
    orderBy?: Enumerable<TransactionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
    [P in keyof T & keyof AggregateTransaction]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }



  export type TransactionSelect = {
    id?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    books?: boolean | BookFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionInclude = {
    user?: boolean | UserArgs
    books?: boolean | BookFindManyArgs
  }

  export type TransactionGetPayload<
    S extends boolean | null | undefined | TransactionArgs,
    U = keyof S
      > = S extends true
        ? Transaction
    : S extends undefined
    ? never
    : S extends TransactionArgs | TransactionFindManyArgs
    ?'include' extends U
    ? Transaction  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'books'
        ? Array < BookGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Transaction ?Transaction [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'books'
        ? Array < BookGetPayload<S['select'][P]>>  : never
  } 
    : Transaction
  : Transaction


  type TransactionCountArgs = Merge<
    Omit<TransactionFindManyArgs, 'select' | 'include'> & {
      select?: TransactionCountAggregateInputType | true
    }
  >

  export interface TransactionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TransactionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TransactionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Transaction'> extends True ? CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>> : CheckSelect<T, Prisma__TransactionClient<Transaction | null >, Prisma__TransactionClient<TransactionGetPayload<T> | null >>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TransactionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TransactionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Transaction'> extends True ? CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>> : CheckSelect<T, Prisma__TransactionClient<Transaction | null >, Prisma__TransactionClient<TransactionGetPayload<T> | null >>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TransactionFindManyArgs>(
      args?: SelectSubset<T, TransactionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Transaction>>, PrismaPromise<Array<TransactionGetPayload<T>>>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
    **/
    create<T extends TransactionCreateArgs>(
      args: SelectSubset<T, TransactionCreateArgs>
    ): CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
    **/
    delete<T extends TransactionDeleteArgs>(
      args: SelectSubset<T, TransactionDeleteArgs>
    ): CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TransactionUpdateArgs>(
      args: SelectSubset<T, TransactionUpdateArgs>
    ): CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TransactionDeleteManyArgs>(
      args?: SelectSubset<T, TransactionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TransactionUpdateManyArgs>(
      args: SelectSubset<T, TransactionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
    **/
    upsert<T extends TransactionUpsertArgs>(
      args: SelectSubset<T, TransactionUpsertArgs>
    ): CheckSelect<T, Prisma__TransactionClient<Transaction>, Prisma__TransactionClient<TransactionGetPayload<T>>>

    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): PrismaPromise<GetTransactionAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TransactionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    books<T extends BookFindManyArgs = {}>(args?: Subset<T, BookFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Book>>, PrismaPromise<Array<BookGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Transaction
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TransactionInclude | null
    /**
     * Throw an Error if a Transaction can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Transaction to fetch.
    **/
    where: TransactionWhereUniqueInput
  }


  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Transaction
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TransactionInclude | null
    /**
     * Throw an Error if a Transaction can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Transaction to fetch.
    **/
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
    **/
    orderBy?: Enumerable<TransactionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
    **/
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
    **/
    distinct?: Enumerable<TransactionScalarFieldEnum>
  }


  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs = {
    /**
     * Select specific fields to fetch from the Transaction
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TransactionInclude | null
    /**
     * Filter, which Transactions to fetch.
    **/
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
    **/
    orderBy?: Enumerable<TransactionOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
    **/
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
    **/
    skip?: number
    distinct?: Enumerable<TransactionScalarFieldEnum>
  }


  /**
   * Transaction create
   */
  export type TransactionCreateArgs = {
    /**
     * Select specific fields to fetch from the Transaction
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TransactionInclude | null
    /**
     * The data needed to create a Transaction.
    **/
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }


  /**
   * Transaction update
   */
  export type TransactionUpdateArgs = {
    /**
     * Select specific fields to fetch from the Transaction
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TransactionInclude | null
    /**
     * The data needed to update a Transaction.
    **/
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
    **/
    where: TransactionWhereUniqueInput
  }


  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs = {
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    where?: TransactionWhereInput
  }


  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs = {
    /**
     * Select specific fields to fetch from the Transaction
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TransactionInclude | null
    /**
     * The filter to search for the Transaction to update in case it exists.
    **/
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
    **/
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }


  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs = {
    /**
     * Select specific fields to fetch from the Transaction
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TransactionInclude | null
    /**
     * Filter which Transaction to delete.
    **/
    where: TransactionWhereUniqueInput
  }


  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs = {
    where?: TransactionWhereInput
  }


  /**
   * Transaction without action
   */
  export type TransactionArgs = {
    /**
     * Select specific fields to fetch from the Transaction
    **/
    select?: TransactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: TransactionInclude | null
  }



  /**
   * Model CreditCard
   */


  export type AggregateCreditCard = {
    count: CreditCardCountAggregateOutputType | null
    min: CreditCardMinAggregateOutputType | null
    max: CreditCardMaxAggregateOutputType | null
  }

  export type CreditCardMinAggregateOutputType = {
    id: string | null
    userId: string | null
    encryptedCreditCardNumber: string | null
    encryptedCCV: string | null
    lastFourDigits: string | null
    expirationDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CreditCardMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    encryptedCreditCardNumber: string | null
    encryptedCCV: string | null
    lastFourDigits: string | null
    expirationDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CreditCardCountAggregateOutputType = {
    id: number | null
    userId: number | null
    encryptedCreditCardNumber: number | null
    encryptedCCV: number | null
    lastFourDigits: number | null
    expirationDate: number | null
    createdAt: number | null
    updatedAt: number | null
    _all: number
  }


  export type CreditCardMinAggregateInputType = {
    id?: true
    userId?: true
    encryptedCreditCardNumber?: true
    encryptedCCV?: true
    lastFourDigits?: true
    expirationDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CreditCardMaxAggregateInputType = {
    id?: true
    userId?: true
    encryptedCreditCardNumber?: true
    encryptedCCV?: true
    lastFourDigits?: true
    expirationDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CreditCardCountAggregateInputType = {
    id?: true
    userId?: true
    encryptedCreditCardNumber?: true
    encryptedCCV?: true
    lastFourDigits?: true
    expirationDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CreditCardAggregateArgs = {
    /**
     * Filter which CreditCard to aggregate.
    **/
    where?: CreditCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditCards to fetch.
    **/
    orderBy?: Enumerable<CreditCardOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CreditCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditCards from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditCards.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditCards
    **/
    count?: true | CreditCardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CreditCardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CreditCardMaxAggregateInputType
  }

  export type GetCreditCardAggregateType<T extends CreditCardAggregateArgs> = {
    [P in keyof T & keyof AggregateCreditCard]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditCard[P]>
      : GetScalarType<T[P], AggregateCreditCard[P]>
  }



  export type CreditCardSelect = {
    id?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    encryptedCreditCardNumber?: boolean
    encryptedCCV?: boolean
    lastFourDigits?: boolean
    expirationDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CreditCardInclude = {
    user?: boolean | UserArgs
  }

  export type CreditCardGetPayload<
    S extends boolean | null | undefined | CreditCardArgs,
    U = keyof S
      > = S extends true
        ? CreditCard
    : S extends undefined
    ? never
    : S extends CreditCardArgs | CreditCardFindManyArgs
    ?'include' extends U
    ? CreditCard  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CreditCard ?CreditCard [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> : never
  } 
    : CreditCard
  : CreditCard


  type CreditCardCountArgs = Merge<
    Omit<CreditCardFindManyArgs, 'select' | 'include'> & {
      select?: CreditCardCountAggregateInputType | true
    }
  >

  export interface CreditCardDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CreditCard that matches the filter.
     * @param {CreditCardFindUniqueArgs} args - Arguments to find a CreditCard
     * @example
     * // Get one CreditCard
     * const creditCard = await prisma.creditCard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CreditCardFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CreditCardFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CreditCard'> extends True ? CheckSelect<T, Prisma__CreditCardClient<CreditCard>, Prisma__CreditCardClient<CreditCardGetPayload<T>>> : CheckSelect<T, Prisma__CreditCardClient<CreditCard | null >, Prisma__CreditCardClient<CreditCardGetPayload<T> | null >>

    /**
     * Find the first CreditCard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditCardFindFirstArgs} args - Arguments to find a CreditCard
     * @example
     * // Get one CreditCard
     * const creditCard = await prisma.creditCard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CreditCardFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CreditCardFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CreditCard'> extends True ? CheckSelect<T, Prisma__CreditCardClient<CreditCard>, Prisma__CreditCardClient<CreditCardGetPayload<T>>> : CheckSelect<T, Prisma__CreditCardClient<CreditCard | null >, Prisma__CreditCardClient<CreditCardGetPayload<T> | null >>

    /**
     * Find zero or more CreditCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditCardFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditCards
     * const creditCards = await prisma.creditCard.findMany()
     * 
     * // Get first 10 CreditCards
     * const creditCards = await prisma.creditCard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditCardWithIdOnly = await prisma.creditCard.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CreditCardFindManyArgs>(
      args?: SelectSubset<T, CreditCardFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CreditCard>>, PrismaPromise<Array<CreditCardGetPayload<T>>>>

    /**
     * Create a CreditCard.
     * @param {CreditCardCreateArgs} args - Arguments to create a CreditCard.
     * @example
     * // Create one CreditCard
     * const CreditCard = await prisma.creditCard.create({
     *   data: {
     *     // ... data to create a CreditCard
     *   }
     * })
     * 
    **/
    create<T extends CreditCardCreateArgs>(
      args: SelectSubset<T, CreditCardCreateArgs>
    ): CheckSelect<T, Prisma__CreditCardClient<CreditCard>, Prisma__CreditCardClient<CreditCardGetPayload<T>>>

    /**
     * Delete a CreditCard.
     * @param {CreditCardDeleteArgs} args - Arguments to delete one CreditCard.
     * @example
     * // Delete one CreditCard
     * const CreditCard = await prisma.creditCard.delete({
     *   where: {
     *     // ... filter to delete one CreditCard
     *   }
     * })
     * 
    **/
    delete<T extends CreditCardDeleteArgs>(
      args: SelectSubset<T, CreditCardDeleteArgs>
    ): CheckSelect<T, Prisma__CreditCardClient<CreditCard>, Prisma__CreditCardClient<CreditCardGetPayload<T>>>

    /**
     * Update one CreditCard.
     * @param {CreditCardUpdateArgs} args - Arguments to update one CreditCard.
     * @example
     * // Update one CreditCard
     * const creditCard = await prisma.creditCard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CreditCardUpdateArgs>(
      args: SelectSubset<T, CreditCardUpdateArgs>
    ): CheckSelect<T, Prisma__CreditCardClient<CreditCard>, Prisma__CreditCardClient<CreditCardGetPayload<T>>>

    /**
     * Delete zero or more CreditCards.
     * @param {CreditCardDeleteManyArgs} args - Arguments to filter CreditCards to delete.
     * @example
     * // Delete a few CreditCards
     * const { count } = await prisma.creditCard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CreditCardDeleteManyArgs>(
      args?: SelectSubset<T, CreditCardDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditCardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditCards
     * const creditCard = await prisma.creditCard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CreditCardUpdateManyArgs>(
      args: SelectSubset<T, CreditCardUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CreditCard.
     * @param {CreditCardUpsertArgs} args - Arguments to update or create a CreditCard.
     * @example
     * // Update or create a CreditCard
     * const creditCard = await prisma.creditCard.upsert({
     *   create: {
     *     // ... data to create a CreditCard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditCard we want to update
     *   }
     * })
    **/
    upsert<T extends CreditCardUpsertArgs>(
      args: SelectSubset<T, CreditCardUpsertArgs>
    ): CheckSelect<T, Prisma__CreditCardClient<CreditCard>, Prisma__CreditCardClient<CreditCardGetPayload<T>>>

    /**
     * Count the number of CreditCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditCardCountArgs} args - Arguments to filter CreditCards to count.
     * @example
     * // Count the number of CreditCards
     * const count = await prisma.creditCard.count({
     *   where: {
     *     // ... the filter for the CreditCards we want to count
     *   }
     * })
    **/
    count<T extends CreditCardCountArgs>(
      args?: Subset<T, CreditCardCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditCardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditCard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditCardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditCardAggregateArgs>(args: Subset<T, CreditCardAggregateArgs>): PrismaPromise<GetCreditCardAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditCard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CreditCardClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CreditCard findUnique
   */
  export type CreditCardFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CreditCard
    **/
    select?: CreditCardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CreditCardInclude | null
    /**
     * Throw an Error if a CreditCard can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CreditCard to fetch.
    **/
    where: CreditCardWhereUniqueInput
  }


  /**
   * CreditCard findFirst
   */
  export type CreditCardFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CreditCard
    **/
    select?: CreditCardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CreditCardInclude | null
    /**
     * Throw an Error if a CreditCard can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CreditCard to fetch.
    **/
    where?: CreditCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditCards to fetch.
    **/
    orderBy?: Enumerable<CreditCardOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditCards.
    **/
    cursor?: CreditCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditCards from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditCards.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditCards.
    **/
    distinct?: Enumerable<CreditCardScalarFieldEnum>
  }


  /**
   * CreditCard findMany
   */
  export type CreditCardFindManyArgs = {
    /**
     * Select specific fields to fetch from the CreditCard
    **/
    select?: CreditCardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CreditCardInclude | null
    /**
     * Filter, which CreditCards to fetch.
    **/
    where?: CreditCardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditCards to fetch.
    **/
    orderBy?: Enumerable<CreditCardOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditCards.
    **/
    cursor?: CreditCardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditCards from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditCards.
    **/
    skip?: number
    distinct?: Enumerable<CreditCardScalarFieldEnum>
  }


  /**
   * CreditCard create
   */
  export type CreditCardCreateArgs = {
    /**
     * Select specific fields to fetch from the CreditCard
    **/
    select?: CreditCardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CreditCardInclude | null
    /**
     * The data needed to create a CreditCard.
    **/
    data: XOR<CreditCardCreateInput, CreditCardUncheckedCreateInput>
  }


  /**
   * CreditCard update
   */
  export type CreditCardUpdateArgs = {
    /**
     * Select specific fields to fetch from the CreditCard
    **/
    select?: CreditCardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CreditCardInclude | null
    /**
     * The data needed to update a CreditCard.
    **/
    data: XOR<CreditCardUpdateInput, CreditCardUncheckedUpdateInput>
    /**
     * Choose, which CreditCard to update.
    **/
    where: CreditCardWhereUniqueInput
  }


  /**
   * CreditCard updateMany
   */
  export type CreditCardUpdateManyArgs = {
    data: XOR<CreditCardUpdateManyMutationInput, CreditCardUncheckedUpdateManyInput>
    where?: CreditCardWhereInput
  }


  /**
   * CreditCard upsert
   */
  export type CreditCardUpsertArgs = {
    /**
     * Select specific fields to fetch from the CreditCard
    **/
    select?: CreditCardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CreditCardInclude | null
    /**
     * The filter to search for the CreditCard to update in case it exists.
    **/
    where: CreditCardWhereUniqueInput
    /**
     * In case the CreditCard found by the `where` argument doesn't exist, create a new CreditCard with this data.
    **/
    create: XOR<CreditCardCreateInput, CreditCardUncheckedCreateInput>
    /**
     * In case the CreditCard was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CreditCardUpdateInput, CreditCardUncheckedUpdateInput>
  }


  /**
   * CreditCard delete
   */
  export type CreditCardDeleteArgs = {
    /**
     * Select specific fields to fetch from the CreditCard
    **/
    select?: CreditCardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CreditCardInclude | null
    /**
     * Filter which CreditCard to delete.
    **/
    where: CreditCardWhereUniqueInput
  }


  /**
   * CreditCard deleteMany
   */
  export type CreditCardDeleteManyArgs = {
    where?: CreditCardWhereInput
  }


  /**
   * CreditCard without action
   */
  export type CreditCardArgs = {
    /**
     * Select specific fields to fetch from the CreditCard
    **/
    select?: CreditCardSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CreditCardInclude | null
  }



  /**
   * Model ShoppingCart
   */


  export type AggregateShoppingCart = {
    count: ShoppingCartCountAggregateOutputType | null
    min: ShoppingCartMinAggregateOutputType | null
    max: ShoppingCartMaxAggregateOutputType | null
  }

  export type ShoppingCartMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShoppingCartMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShoppingCartCountAggregateOutputType = {
    id: number | null
    userId: number | null
    createdAt: number | null
    updatedAt: number | null
    _all: number
  }


  export type ShoppingCartMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShoppingCartMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShoppingCartCountAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShoppingCartAggregateArgs = {
    /**
     * Filter which ShoppingCart to aggregate.
    **/
    where?: ShoppingCartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShoppingCarts to fetch.
    **/
    orderBy?: Enumerable<ShoppingCartOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ShoppingCartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShoppingCarts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShoppingCarts.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShoppingCarts
    **/
    count?: true | ShoppingCartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ShoppingCartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ShoppingCartMaxAggregateInputType
  }

  export type GetShoppingCartAggregateType<T extends ShoppingCartAggregateArgs> = {
    [P in keyof T & keyof AggregateShoppingCart]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShoppingCart[P]>
      : GetScalarType<T[P], AggregateShoppingCart[P]>
  }



  export type ShoppingCartSelect = {
    id?: boolean
    user?: boolean | UserArgs
    userId?: boolean
    books?: boolean | BookFindManyArgs
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShoppingCartInclude = {
    user?: boolean | UserArgs
    books?: boolean | BookFindManyArgs
  }

  export type ShoppingCartGetPayload<
    S extends boolean | null | undefined | ShoppingCartArgs,
    U = keyof S
      > = S extends true
        ? ShoppingCart
    : S extends undefined
    ? never
    : S extends ShoppingCartArgs | ShoppingCartFindManyArgs
    ?'include' extends U
    ? ShoppingCart  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'user'
        ? UserGetPayload<S['include'][P]> :
        P extends 'books'
        ? Array < BookGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ShoppingCart ?ShoppingCart [P]
  : 
          P extends 'user'
        ? UserGetPayload<S['select'][P]> :
        P extends 'books'
        ? Array < BookGetPayload<S['select'][P]>>  : never
  } 
    : ShoppingCart
  : ShoppingCart


  type ShoppingCartCountArgs = Merge<
    Omit<ShoppingCartFindManyArgs, 'select' | 'include'> & {
      select?: ShoppingCartCountAggregateInputType | true
    }
  >

  export interface ShoppingCartDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ShoppingCart that matches the filter.
     * @param {ShoppingCartFindUniqueArgs} args - Arguments to find a ShoppingCart
     * @example
     * // Get one ShoppingCart
     * const shoppingCart = await prisma.shoppingCart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ShoppingCartFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ShoppingCartFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ShoppingCart'> extends True ? CheckSelect<T, Prisma__ShoppingCartClient<ShoppingCart>, Prisma__ShoppingCartClient<ShoppingCartGetPayload<T>>> : CheckSelect<T, Prisma__ShoppingCartClient<ShoppingCart | null >, Prisma__ShoppingCartClient<ShoppingCartGetPayload<T> | null >>

    /**
     * Find the first ShoppingCart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingCartFindFirstArgs} args - Arguments to find a ShoppingCart
     * @example
     * // Get one ShoppingCart
     * const shoppingCart = await prisma.shoppingCart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ShoppingCartFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ShoppingCartFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ShoppingCart'> extends True ? CheckSelect<T, Prisma__ShoppingCartClient<ShoppingCart>, Prisma__ShoppingCartClient<ShoppingCartGetPayload<T>>> : CheckSelect<T, Prisma__ShoppingCartClient<ShoppingCart | null >, Prisma__ShoppingCartClient<ShoppingCartGetPayload<T> | null >>

    /**
     * Find zero or more ShoppingCarts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingCartFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShoppingCarts
     * const shoppingCarts = await prisma.shoppingCart.findMany()
     * 
     * // Get first 10 ShoppingCarts
     * const shoppingCarts = await prisma.shoppingCart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shoppingCartWithIdOnly = await prisma.shoppingCart.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ShoppingCartFindManyArgs>(
      args?: SelectSubset<T, ShoppingCartFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ShoppingCart>>, PrismaPromise<Array<ShoppingCartGetPayload<T>>>>

    /**
     * Create a ShoppingCart.
     * @param {ShoppingCartCreateArgs} args - Arguments to create a ShoppingCart.
     * @example
     * // Create one ShoppingCart
     * const ShoppingCart = await prisma.shoppingCart.create({
     *   data: {
     *     // ... data to create a ShoppingCart
     *   }
     * })
     * 
    **/
    create<T extends ShoppingCartCreateArgs>(
      args: SelectSubset<T, ShoppingCartCreateArgs>
    ): CheckSelect<T, Prisma__ShoppingCartClient<ShoppingCart>, Prisma__ShoppingCartClient<ShoppingCartGetPayload<T>>>

    /**
     * Delete a ShoppingCart.
     * @param {ShoppingCartDeleteArgs} args - Arguments to delete one ShoppingCart.
     * @example
     * // Delete one ShoppingCart
     * const ShoppingCart = await prisma.shoppingCart.delete({
     *   where: {
     *     // ... filter to delete one ShoppingCart
     *   }
     * })
     * 
    **/
    delete<T extends ShoppingCartDeleteArgs>(
      args: SelectSubset<T, ShoppingCartDeleteArgs>
    ): CheckSelect<T, Prisma__ShoppingCartClient<ShoppingCart>, Prisma__ShoppingCartClient<ShoppingCartGetPayload<T>>>

    /**
     * Update one ShoppingCart.
     * @param {ShoppingCartUpdateArgs} args - Arguments to update one ShoppingCart.
     * @example
     * // Update one ShoppingCart
     * const shoppingCart = await prisma.shoppingCart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ShoppingCartUpdateArgs>(
      args: SelectSubset<T, ShoppingCartUpdateArgs>
    ): CheckSelect<T, Prisma__ShoppingCartClient<ShoppingCart>, Prisma__ShoppingCartClient<ShoppingCartGetPayload<T>>>

    /**
     * Delete zero or more ShoppingCarts.
     * @param {ShoppingCartDeleteManyArgs} args - Arguments to filter ShoppingCarts to delete.
     * @example
     * // Delete a few ShoppingCarts
     * const { count } = await prisma.shoppingCart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ShoppingCartDeleteManyArgs>(
      args?: SelectSubset<T, ShoppingCartDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShoppingCarts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingCartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShoppingCarts
     * const shoppingCart = await prisma.shoppingCart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ShoppingCartUpdateManyArgs>(
      args: SelectSubset<T, ShoppingCartUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ShoppingCart.
     * @param {ShoppingCartUpsertArgs} args - Arguments to update or create a ShoppingCart.
     * @example
     * // Update or create a ShoppingCart
     * const shoppingCart = await prisma.shoppingCart.upsert({
     *   create: {
     *     // ... data to create a ShoppingCart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShoppingCart we want to update
     *   }
     * })
    **/
    upsert<T extends ShoppingCartUpsertArgs>(
      args: SelectSubset<T, ShoppingCartUpsertArgs>
    ): CheckSelect<T, Prisma__ShoppingCartClient<ShoppingCart>, Prisma__ShoppingCartClient<ShoppingCartGetPayload<T>>>

    /**
     * Count the number of ShoppingCarts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingCartCountArgs} args - Arguments to filter ShoppingCarts to count.
     * @example
     * // Count the number of ShoppingCarts
     * const count = await prisma.shoppingCart.count({
     *   where: {
     *     // ... the filter for the ShoppingCarts we want to count
     *   }
     * })
    **/
    count<T extends ShoppingCartCountArgs>(
      args?: Subset<T, ShoppingCartCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShoppingCartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShoppingCart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShoppingCartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShoppingCartAggregateArgs>(args: Subset<T, ShoppingCartAggregateArgs>): PrismaPromise<GetShoppingCartAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for ShoppingCart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ShoppingCartClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user<T extends UserArgs = {}>(args?: Subset<T, UserArgs>): CheckSelect<T, Prisma__UserClient<User | null >, Prisma__UserClient<UserGetPayload<T> | null >>;

    books<T extends BookFindManyArgs = {}>(args?: Subset<T, BookFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Book>>, PrismaPromise<Array<BookGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ShoppingCart findUnique
   */
  export type ShoppingCartFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ShoppingCart
    **/
    select?: ShoppingCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ShoppingCartInclude | null
    /**
     * Throw an Error if a ShoppingCart can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ShoppingCart to fetch.
    **/
    where: ShoppingCartWhereUniqueInput
  }


  /**
   * ShoppingCart findFirst
   */
  export type ShoppingCartFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ShoppingCart
    **/
    select?: ShoppingCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ShoppingCartInclude | null
    /**
     * Throw an Error if a ShoppingCart can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ShoppingCart to fetch.
    **/
    where?: ShoppingCartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShoppingCarts to fetch.
    **/
    orderBy?: Enumerable<ShoppingCartOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShoppingCarts.
    **/
    cursor?: ShoppingCartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShoppingCarts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShoppingCarts.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShoppingCarts.
    **/
    distinct?: Enumerable<ShoppingCartScalarFieldEnum>
  }


  /**
   * ShoppingCart findMany
   */
  export type ShoppingCartFindManyArgs = {
    /**
     * Select specific fields to fetch from the ShoppingCart
    **/
    select?: ShoppingCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ShoppingCartInclude | null
    /**
     * Filter, which ShoppingCarts to fetch.
    **/
    where?: ShoppingCartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShoppingCarts to fetch.
    **/
    orderBy?: Enumerable<ShoppingCartOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShoppingCarts.
    **/
    cursor?: ShoppingCartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShoppingCarts from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShoppingCarts.
    **/
    skip?: number
    distinct?: Enumerable<ShoppingCartScalarFieldEnum>
  }


  /**
   * ShoppingCart create
   */
  export type ShoppingCartCreateArgs = {
    /**
     * Select specific fields to fetch from the ShoppingCart
    **/
    select?: ShoppingCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ShoppingCartInclude | null
    /**
     * The data needed to create a ShoppingCart.
    **/
    data: XOR<ShoppingCartCreateInput, ShoppingCartUncheckedCreateInput>
  }


  /**
   * ShoppingCart update
   */
  export type ShoppingCartUpdateArgs = {
    /**
     * Select specific fields to fetch from the ShoppingCart
    **/
    select?: ShoppingCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ShoppingCartInclude | null
    /**
     * The data needed to update a ShoppingCart.
    **/
    data: XOR<ShoppingCartUpdateInput, ShoppingCartUncheckedUpdateInput>
    /**
     * Choose, which ShoppingCart to update.
    **/
    where: ShoppingCartWhereUniqueInput
  }


  /**
   * ShoppingCart updateMany
   */
  export type ShoppingCartUpdateManyArgs = {
    data: XOR<ShoppingCartUpdateManyMutationInput, ShoppingCartUncheckedUpdateManyInput>
    where?: ShoppingCartWhereInput
  }


  /**
   * ShoppingCart upsert
   */
  export type ShoppingCartUpsertArgs = {
    /**
     * Select specific fields to fetch from the ShoppingCart
    **/
    select?: ShoppingCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ShoppingCartInclude | null
    /**
     * The filter to search for the ShoppingCart to update in case it exists.
    **/
    where: ShoppingCartWhereUniqueInput
    /**
     * In case the ShoppingCart found by the `where` argument doesn't exist, create a new ShoppingCart with this data.
    **/
    create: XOR<ShoppingCartCreateInput, ShoppingCartUncheckedCreateInput>
    /**
     * In case the ShoppingCart was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ShoppingCartUpdateInput, ShoppingCartUncheckedUpdateInput>
  }


  /**
   * ShoppingCart delete
   */
  export type ShoppingCartDeleteArgs = {
    /**
     * Select specific fields to fetch from the ShoppingCart
    **/
    select?: ShoppingCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ShoppingCartInclude | null
    /**
     * Filter which ShoppingCart to delete.
    **/
    where: ShoppingCartWhereUniqueInput
  }


  /**
   * ShoppingCart deleteMany
   */
  export type ShoppingCartDeleteManyArgs = {
    where?: ShoppingCartWhereInput
  }


  /**
   * ShoppingCart without action
   */
  export type ShoppingCartArgs = {
    /**
     * Select specific fields to fetch from the ShoppingCart
    **/
    select?: ShoppingCartSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ShoppingCartInclude | null
  }



  /**
   * Model Role
   */


  export type AggregateRole = {
    count: RoleCountAggregateOutputType | null
    avg: RoleAvgAggregateOutputType | null
    sum: RoleSumAggregateOutputType | null
    min: RoleMinAggregateOutputType | null
    max: RoleMaxAggregateOutputType | null
  }

  export type RoleAvgAggregateOutputType = {
    id: number
  }

  export type RoleSumAggregateOutputType = {
    id: number
  }

  export type RoleMinAggregateOutputType = {
    id: number
    name: string | null
  }

  export type RoleMaxAggregateOutputType = {
    id: number
    name: string | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number | null
    _all: number
  }


  export type RoleAvgAggregateInputType = {
    id?: true
  }

  export type RoleSumAggregateInputType = {
    id?: true
  }

  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RoleAggregateArgs = {
    /**
     * Filter which Role to aggregate.
    **/
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
    **/
    orderBy?: Enumerable<RoleOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: RoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: RoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
    [P in keyof T & keyof AggregateRole]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }



  export type RoleSelect = {
    id?: boolean
    name?: boolean
    users?: boolean | UserFindManyArgs
  }

  export type RoleInclude = {
    users?: boolean | UserFindManyArgs
  }

  export type RoleGetPayload<
    S extends boolean | null | undefined | RoleArgs,
    U = keyof S
      > = S extends true
        ? Role
    : S extends undefined
    ? never
    : S extends RoleArgs | RoleFindManyArgs
    ?'include' extends U
    ? Role  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'users'
        ? Array < UserGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Role ?Role [P]
  : 
          P extends 'users'
        ? Array < UserGetPayload<S['select'][P]>>  : never
  } 
    : Role
  : Role


  type RoleCountArgs = Merge<
    Omit<RoleFindManyArgs, 'select' | 'include'> & {
      select?: RoleCountAggregateInputType | true
    }
  >

  export interface RoleDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RoleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RoleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Role'> extends True ? CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>> : CheckSelect<T, Prisma__RoleClient<Role | null >, Prisma__RoleClient<RoleGetPayload<T> | null >>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RoleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RoleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Role'> extends True ? CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>> : CheckSelect<T, Prisma__RoleClient<Role | null >, Prisma__RoleClient<RoleGetPayload<T> | null >>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RoleFindManyArgs>(
      args?: SelectSubset<T, RoleFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Role>>, PrismaPromise<Array<RoleGetPayload<T>>>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
    **/
    create<T extends RoleCreateArgs>(
      args: SelectSubset<T, RoleCreateArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
    **/
    delete<T extends RoleDeleteArgs>(
      args: SelectSubset<T, RoleDeleteArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RoleUpdateArgs>(
      args: SelectSubset<T, RoleUpdateArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RoleDeleteManyArgs>(
      args?: SelectSubset<T, RoleDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RoleUpdateManyArgs>(
      args: SelectSubset<T, RoleUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
    **/
    upsert<T extends RoleUpsertArgs>(
      args: SelectSubset<T, RoleUpsertArgs>
    ): CheckSelect<T, Prisma__RoleClient<Role>, Prisma__RoleClient<RoleGetPayload<T>>>

    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): PrismaPromise<GetRoleAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RoleClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    users<T extends UserFindManyArgs = {}>(args?: Subset<T, UserFindManyArgs>): CheckSelect<T, PrismaPromise<Array<User>>, PrismaPromise<Array<UserGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Role
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RoleInclude | null
    /**
     * Throw an Error if a Role can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Role to fetch.
    **/
    where: RoleWhereUniqueInput
  }


  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Role
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RoleInclude | null
    /**
     * Throw an Error if a Role can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Role to fetch.
    **/
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
    **/
    orderBy?: Enumerable<RoleOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
    **/
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
    **/
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role findMany
   */
  export type RoleFindManyArgs = {
    /**
     * Select specific fields to fetch from the Role
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RoleInclude | null
    /**
     * Filter, which Roles to fetch.
    **/
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
    **/
    orderBy?: Enumerable<RoleOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
    **/
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
    **/
    skip?: number
    distinct?: Enumerable<RoleScalarFieldEnum>
  }


  /**
   * Role create
   */
  export type RoleCreateArgs = {
    /**
     * Select specific fields to fetch from the Role
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RoleInclude | null
    /**
     * The data needed to create a Role.
    **/
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }


  /**
   * Role update
   */
  export type RoleUpdateArgs = {
    /**
     * Select specific fields to fetch from the Role
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RoleInclude | null
    /**
     * The data needed to update a Role.
    **/
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
    **/
    where: RoleWhereUniqueInput
  }


  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs = {
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    where?: RoleWhereInput
  }


  /**
   * Role upsert
   */
  export type RoleUpsertArgs = {
    /**
     * Select specific fields to fetch from the Role
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RoleInclude | null
    /**
     * The filter to search for the Role to update in case it exists.
    **/
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
    **/
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }


  /**
   * Role delete
   */
  export type RoleDeleteArgs = {
    /**
     * Select specific fields to fetch from the Role
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RoleInclude | null
    /**
     * Filter which Role to delete.
    **/
    where: RoleWhereUniqueInput
  }


  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs = {
    where?: RoleWhereInput
  }


  /**
   * Role without action
   */
  export type RoleArgs = {
    /**
     * Select specific fields to fetch from the Role
    **/
    select?: RoleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RoleInclude | null
  }



  /**
   * Model Log
   */


  export type AggregateLog = {
    count: LogCountAggregateOutputType | null
    min: LogMinAggregateOutputType | null
    max: LogMaxAggregateOutputType | null
  }

  export type LogMinAggregateOutputType = {
    id: string | null
    name: string | null
    message: string | null
    createdAt: Date | null
  }

  export type LogMaxAggregateOutputType = {
    id: string | null
    name: string | null
    message: string | null
    createdAt: Date | null
  }

  export type LogCountAggregateOutputType = {
    id: number | null
    name: number | null
    message: number | null
    createdAt: number | null
    _all: number
  }


  export type LogMinAggregateInputType = {
    id?: true
    name?: true
    message?: true
    createdAt?: true
  }

  export type LogMaxAggregateInputType = {
    id?: true
    name?: true
    message?: true
    createdAt?: true
  }

  export type LogCountAggregateInputType = {
    id?: true
    name?: true
    message?: true
    createdAt?: true
    _all?: true
  }

  export type LogAggregateArgs = {
    /**
     * Filter which Log to aggregate.
    **/
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
    **/
    orderBy?: Enumerable<LogOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logs
    **/
    count?: true | LogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: LogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: LogMaxAggregateInputType
  }

  export type GetLogAggregateType<T extends LogAggregateArgs> = {
    [P in keyof T & keyof AggregateLog]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLog[P]>
      : GetScalarType<T[P], AggregateLog[P]>
  }



  export type LogSelect = {
    id?: boolean
    name?: boolean
    message?: boolean
    createdAt?: boolean
  }

  export type LogGetPayload<
    S extends boolean | null | undefined | LogArgs,
    U = keyof S
      > = S extends true
        ? Log
    : S extends undefined
    ? never
    : S extends LogArgs | LogFindManyArgs
    ?'include' extends U
    ? Log 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof Log ?Log [P]
  : 
     never
  } 
    : Log
  : Log


  type LogCountArgs = Merge<
    Omit<LogFindManyArgs, 'select' | 'include'> & {
      select?: LogCountAggregateInputType | true
    }
  >

  export interface LogDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Log that matches the filter.
     * @param {LogFindUniqueArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LogFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LogFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Log'> extends True ? CheckSelect<T, Prisma__LogClient<Log>, Prisma__LogClient<LogGetPayload<T>>> : CheckSelect<T, Prisma__LogClient<Log | null >, Prisma__LogClient<LogGetPayload<T> | null >>

    /**
     * Find the first Log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LogFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LogFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Log'> extends True ? CheckSelect<T, Prisma__LogClient<Log>, Prisma__LogClient<LogGetPayload<T>>> : CheckSelect<T, Prisma__LogClient<Log | null >, Prisma__LogClient<LogGetPayload<T> | null >>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.log.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logWithIdOnly = await prisma.log.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LogFindManyArgs>(
      args?: SelectSubset<T, LogFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Log>>, PrismaPromise<Array<LogGetPayload<T>>>>

    /**
     * Create a Log.
     * @param {LogCreateArgs} args - Arguments to create a Log.
     * @example
     * // Create one Log
     * const Log = await prisma.log.create({
     *   data: {
     *     // ... data to create a Log
     *   }
     * })
     * 
    **/
    create<T extends LogCreateArgs>(
      args: SelectSubset<T, LogCreateArgs>
    ): CheckSelect<T, Prisma__LogClient<Log>, Prisma__LogClient<LogGetPayload<T>>>

    /**
     * Delete a Log.
     * @param {LogDeleteArgs} args - Arguments to delete one Log.
     * @example
     * // Delete one Log
     * const Log = await prisma.log.delete({
     *   where: {
     *     // ... filter to delete one Log
     *   }
     * })
     * 
    **/
    delete<T extends LogDeleteArgs>(
      args: SelectSubset<T, LogDeleteArgs>
    ): CheckSelect<T, Prisma__LogClient<Log>, Prisma__LogClient<LogGetPayload<T>>>

    /**
     * Update one Log.
     * @param {LogUpdateArgs} args - Arguments to update one Log.
     * @example
     * // Update one Log
     * const log = await prisma.log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LogUpdateArgs>(
      args: SelectSubset<T, LogUpdateArgs>
    ): CheckSelect<T, Prisma__LogClient<Log>, Prisma__LogClient<LogGetPayload<T>>>

    /**
     * Delete zero or more Logs.
     * @param {LogDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LogDeleteManyArgs>(
      args?: SelectSubset<T, LogDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LogUpdateManyArgs>(
      args: SelectSubset<T, LogUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Log.
     * @param {LogUpsertArgs} args - Arguments to update or create a Log.
     * @example
     * // Update or create a Log
     * const log = await prisma.log.upsert({
     *   create: {
     *     // ... data to create a Log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Log we want to update
     *   }
     * })
    **/
    upsert<T extends LogUpsertArgs>(
      args: SelectSubset<T, LogUpsertArgs>
    ): CheckSelect<T, Prisma__LogClient<Log>, Prisma__LogClient<LogGetPayload<T>>>

    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.log.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends LogCountArgs>(
      args?: Subset<T, LogCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogAggregateArgs>(args: Subset<T, LogAggregateArgs>): PrismaPromise<GetLogAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for Log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LogClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Log findUnique
   */
  export type LogFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Log
    **/
    select?: LogSelect | null
    /**
     * Throw an Error if a Log can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Log to fetch.
    **/
    where: LogWhereUniqueInput
  }


  /**
   * Log findFirst
   */
  export type LogFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Log
    **/
    select?: LogSelect | null
    /**
     * Throw an Error if a Log can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Log to fetch.
    **/
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
    **/
    orderBy?: Enumerable<LogOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
    **/
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
    **/
    distinct?: Enumerable<LogScalarFieldEnum>
  }


  /**
   * Log findMany
   */
  export type LogFindManyArgs = {
    /**
     * Select specific fields to fetch from the Log
    **/
    select?: LogSelect | null
    /**
     * Filter, which Logs to fetch.
    **/
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
    **/
    orderBy?: Enumerable<LogOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logs.
    **/
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
    **/
    skip?: number
    distinct?: Enumerable<LogScalarFieldEnum>
  }


  /**
   * Log create
   */
  export type LogCreateArgs = {
    /**
     * Select specific fields to fetch from the Log
    **/
    select?: LogSelect | null
    /**
     * The data needed to create a Log.
    **/
    data: XOR<LogCreateInput, LogUncheckedCreateInput>
  }


  /**
   * Log update
   */
  export type LogUpdateArgs = {
    /**
     * Select specific fields to fetch from the Log
    **/
    select?: LogSelect | null
    /**
     * The data needed to update a Log.
    **/
    data: XOR<LogUpdateInput, LogUncheckedUpdateInput>
    /**
     * Choose, which Log to update.
    **/
    where: LogWhereUniqueInput
  }


  /**
   * Log updateMany
   */
  export type LogUpdateManyArgs = {
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    where?: LogWhereInput
  }


  /**
   * Log upsert
   */
  export type LogUpsertArgs = {
    /**
     * Select specific fields to fetch from the Log
    **/
    select?: LogSelect | null
    /**
     * The filter to search for the Log to update in case it exists.
    **/
    where: LogWhereUniqueInput
    /**
     * In case the Log found by the `where` argument doesn't exist, create a new Log with this data.
    **/
    create: XOR<LogCreateInput, LogUncheckedCreateInput>
    /**
     * In case the Log was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<LogUpdateInput, LogUncheckedUpdateInput>
  }


  /**
   * Log delete
   */
  export type LogDeleteArgs = {
    /**
     * Select specific fields to fetch from the Log
    **/
    select?: LogSelect | null
    /**
     * Filter which Log to delete.
    **/
    where: LogWhereUniqueInput
  }


  /**
   * Log deleteMany
   */
  export type LogDeleteManyArgs = {
    where?: LogWhereInput
  }


  /**
   * Log without action
   */
  export type LogArgs = {
    /**
     * Select specific fields to fetch from the Log
    **/
    select?: LogSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    nickName: 'nickName',
    profilePicture: 'profilePicture',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const BookScalarFieldEnum: {
    id: 'id',
    title: 'title',
    publisherId: 'publisherId',
    publishYear: 'publishYear',
    isbn: 'isbn',
    description: 'description',
    price: 'price',
    coverUrl: 'coverUrl',
    coverDataUri: 'coverDataUri',
    sold: 'sold',
    transactionId: 'transactionId',
    shoppingCartId: 'shoppingCartId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookScalarFieldEnum = (typeof BookScalarFieldEnum)[keyof typeof BookScalarFieldEnum]


  export const AuthorScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuthorScalarFieldEnum = (typeof AuthorScalarFieldEnum)[keyof typeof AuthorScalarFieldEnum]


  export const PublisherScalarFieldEnum: {
    id: 'id',
    name: 'name',
    city: 'city',
    state: 'state',
    website: 'website'
  };

  export type PublisherScalarFieldEnum = (typeof PublisherScalarFieldEnum)[keyof typeof PublisherScalarFieldEnum]


  export const GenreScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type GenreScalarFieldEnum = (typeof GenreScalarFieldEnum)[keyof typeof GenreScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    value: 'value',
    description: 'description',
    postedAs: 'postedAs',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    bookId: 'bookId'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    street: 'street',
    apartmentOrUnit: 'apartmentOrUnit',
    city: 'city',
    state: 'state',
    country: 'country',
    zipcode: 'zipcode',
    userShippingAddressId: 'userShippingAddressId'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const CreditCardScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    encryptedCreditCardNumber: 'encryptedCreditCardNumber',
    encryptedCCV: 'encryptedCCV',
    lastFourDigits: 'lastFourDigits',
    expirationDate: 'expirationDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CreditCardScalarFieldEnum = (typeof CreditCardScalarFieldEnum)[keyof typeof CreditCardScalarFieldEnum]


  export const ShoppingCartScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShoppingCartScalarFieldEnum = (typeof ShoppingCartScalarFieldEnum)[keyof typeof ShoppingCartScalarFieldEnum]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const LogScalarFieldEnum: {
    id: 'id',
    name: 'name',
    message: 'message',
    createdAt: 'createdAt'
  };

  export type LogScalarFieldEnum = (typeof LogScalarFieldEnum)[keyof typeof LogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    email?: StringFilter | string
    passwordHash?: StringNullableFilter | string | null
    firstName?: StringNullableFilter | string | null
    middleName?: StringNullableFilter | string | null
    lastName?: StringNullableFilter | string | null
    nickName?: StringNullableFilter | string | null
    profilePicture?: StringNullableFilter | string | null
    transactions?: TransactionListRelationFilter
    shippingAddresses?: AddressListRelationFilter
    creditCards?: CreditCardListRelationFilter
    roles?: RoleListRelationFilter
    reviews?: ReviewListRelationFilter
    shoppingCart?: ShoppingCartListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type UserOrderByInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    nickName?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
    nickName?: string
  }

  export type BookWhereInput = {
    AND?: Enumerable<BookWhereInput>
    OR?: Enumerable<BookWhereInput>
    NOT?: Enumerable<BookWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    authors?: AuthorListRelationFilter
    publisher?: XOR<PublisherRelationFilter, PublisherWhereInput>
    publisherId?: StringFilter | string
    publishYear?: IntFilter | number
    isbn?: IntFilter | number
    description?: StringFilter | string
    genres?: GenreListRelationFilter
    price?: FloatFilter | number
    reviews?: ReviewListRelationFilter
    coverUrl?: StringNullableFilter | string | null
    coverDataUri?: StringNullableFilter | string | null
    sold?: IntFilter | number
    transaction?: XOR<TransactionRelationFilter, TransactionWhereInput> | null
    transactionId?: StringNullableFilter | string | null
    shoppingCart?: XOR<ShoppingCartRelationFilter, ShoppingCartWhereInput> | null
    shoppingCartId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BookOrderByInput = {
    id?: SortOrder
    title?: SortOrder
    publisher?: PublisherOrderByInput
    publisherId?: SortOrder
    publishYear?: SortOrder
    isbn?: SortOrder
    description?: SortOrder
    price?: SortOrder
    coverUrl?: SortOrder
    coverDataUri?: SortOrder
    sold?: SortOrder
    transaction?: TransactionOrderByInput
    transactionId?: SortOrder
    shoppingCart?: ShoppingCartOrderByInput
    shoppingCartId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookWhereUniqueInput = {
    id?: string
    title?: string
    isbn?: number
  }

  export type AuthorWhereInput = {
    AND?: Enumerable<AuthorWhereInput>
    OR?: Enumerable<AuthorWhereInput>
    NOT?: Enumerable<AuthorWhereInput>
    id?: StringFilter | string
    firstName?: StringFilter | string
    middleName?: StringNullableFilter | string | null
    lastName?: StringFilter | string
    description?: StringFilter | string
    books?: BookListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type AuthorOrderByInput = {
    id?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthorWhereUniqueInput = {
    id?: string
    firstName_middleName_lastName?: AuthorFirstNameMiddleNameLastNameCompoundUniqueInput
  }

  export type PublisherWhereInput = {
    AND?: Enumerable<PublisherWhereInput>
    OR?: Enumerable<PublisherWhereInput>
    NOT?: Enumerable<PublisherWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    city?: StringFilter | string
    state?: StringFilter | string
    website?: StringNullableFilter | string | null
    book?: BookListRelationFilter
  }

  export type PublisherOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    state?: SortOrder
    website?: SortOrder
  }

  export type PublisherWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type GenreWhereInput = {
    AND?: Enumerable<GenreWhereInput>
    OR?: Enumerable<GenreWhereInput>
    NOT?: Enumerable<GenreWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    books?: BookListRelationFilter
  }

  export type GenreOrderByInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type GenreWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type ReviewWhereInput = {
    AND?: Enumerable<ReviewWhereInput>
    OR?: Enumerable<ReviewWhereInput>
    NOT?: Enumerable<ReviewWhereInput>
    id?: StringFilter | string
    value?: IntFilter | number
    description?: StringFilter | string
    postedAs?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
    book?: XOR<BookRelationFilter, BookWhereInput>
    bookId?: StringFilter | string
  }

  export type ReviewOrderByInput = {
    id?: SortOrder
    value?: SortOrder
    description?: SortOrder
    postedAs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByInput
    userId?: SortOrder
    book?: BookOrderByInput
    bookId?: SortOrder
  }

  export type ReviewWhereUniqueInput = {
    id?: string
  }

  export type AddressWhereInput = {
    AND?: Enumerable<AddressWhereInput>
    OR?: Enumerable<AddressWhereInput>
    NOT?: Enumerable<AddressWhereInput>
    id?: StringFilter | string
    street?: StringFilter | string
    apartmentOrUnit?: StringNullableFilter | string | null
    city?: StringFilter | string
    state?: StringFilter | string
    country?: StringFilter | string
    zipcode?: StringFilter | string
    userShippingAddress?: XOR<UserRelationFilter, UserWhereInput>
    userShippingAddressId?: StringFilter | string
  }

  export type AddressOrderByInput = {
    id?: SortOrder
    street?: SortOrder
    apartmentOrUnit?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    zipcode?: SortOrder
    userShippingAddress?: UserOrderByInput
    userShippingAddressId?: SortOrder
  }

  export type AddressWhereUniqueInput = {
    id?: string
  }

  export type TransactionWhereInput = {
    AND?: Enumerable<TransactionWhereInput>
    OR?: Enumerable<TransactionWhereInput>
    NOT?: Enumerable<TransactionWhereInput>
    id?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
    books?: BookListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TransactionOrderByInput = {
    id?: SortOrder
    user?: UserOrderByInput
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionWhereUniqueInput = {
    id?: string
  }

  export type CreditCardWhereInput = {
    AND?: Enumerable<CreditCardWhereInput>
    OR?: Enumerable<CreditCardWhereInput>
    NOT?: Enumerable<CreditCardWhereInput>
    id?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
    encryptedCreditCardNumber?: StringFilter | string
    encryptedCCV?: StringFilter | string
    lastFourDigits?: StringFilter | string
    expirationDate?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CreditCardOrderByInput = {
    id?: SortOrder
    user?: UserOrderByInput
    userId?: SortOrder
    encryptedCreditCardNumber?: SortOrder
    encryptedCCV?: SortOrder
    lastFourDigits?: SortOrder
    expirationDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CreditCardWhereUniqueInput = {
    id?: string
  }

  export type ShoppingCartWhereInput = {
    AND?: Enumerable<ShoppingCartWhereInput>
    OR?: Enumerable<ShoppingCartWhereInput>
    NOT?: Enumerable<ShoppingCartWhereInput>
    id?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    userId?: StringFilter | string
    books?: BookListRelationFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type ShoppingCartOrderByInput = {
    id?: SortOrder
    user?: UserOrderByInput
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShoppingCartWhereUniqueInput = {
    id?: string
  }

  export type RoleWhereInput = {
    AND?: Enumerable<RoleWhereInput>
    OR?: Enumerable<RoleWhereInput>
    NOT?: Enumerable<RoleWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    users?: UserListRelationFilter
  }

  export type RoleOrderByInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RoleWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type LogWhereInput = {
    AND?: Enumerable<LogWhereInput>
    OR?: Enumerable<LogWhereInput>
    NOT?: Enumerable<LogWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    message?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type LogOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type LogWhereUniqueInput = {
    id?: string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    nickName?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutUserInput
    shippingAddresses?: AddressCreateNestedManyWithoutUserShippingAddressInput
    creditCards?: CreditCardCreateNestedManyWithoutUserInput
    roles?: RoleCreateNestedManyWithoutUsersInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    shoppingCart?: ShoppingCartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    nickName?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    shippingAddresses?: AddressUncheckedCreateNestedManyWithoutUserShippingAddressInput
    creditCards?: CreditCardUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    shoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutUserInput
    shippingAddresses?: AddressUpdateManyWithoutUserShippingAddressInput
    creditCards?: CreditCardUpdateManyWithoutUserInput
    roles?: RoleUpdateManyWithoutUsersInput
    reviews?: ReviewUpdateManyWithoutUserInput
    shoppingCart?: ShoppingCartUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutUserInput
    shippingAddresses?: AddressUncheckedUpdateManyWithoutUserShippingAddressInput
    creditCards?: CreditCardUncheckedUpdateManyWithoutUserInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserInput
    shoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUserInput
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookCreateInput = {
    id?: string
    title: string
    publishYear: number
    isbn: number
    description: string
    price: number
    coverUrl?: string | null
    coverDataUri?: string | null
    sold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authors?: AuthorCreateNestedManyWithoutBooksInput
    publisher: PublisherCreateNestedOneWithoutBookInput
    genres?: GenreCreateNestedManyWithoutBooksInput
    reviews?: ReviewCreateNestedManyWithoutBookInput
    transaction?: TransactionCreateNestedOneWithoutBooksInput
    shoppingCart?: ShoppingCartCreateNestedOneWithoutBooksInput
  }

  export type BookUncheckedCreateInput = {
    id?: string
    title: string
    publisherId: string
    publishYear: number
    isbn: number
    description: string
    price: number
    coverUrl?: string | null
    coverDataUri?: string | null
    sold?: number
    transactionId?: string | null
    shoppingCartId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookInput
  }

  export type BookUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    publishYear?: IntFieldUpdateOperationsInput | number
    isbn?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverDataUri?: NullableStringFieldUpdateOperationsInput | string | null
    sold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authors?: AuthorUpdateManyWithoutBooksInput
    publisher?: PublisherUpdateOneRequiredWithoutBookInput
    genres?: GenreUpdateManyWithoutBooksInput
    reviews?: ReviewUpdateManyWithoutBookInput
    transaction?: TransactionUpdateOneWithoutBooksInput
    shoppingCart?: ShoppingCartUpdateOneWithoutBooksInput
  }

  export type BookUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    publisherId?: StringFieldUpdateOperationsInput | string
    publishYear?: IntFieldUpdateOperationsInput | number
    isbn?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverDataUri?: NullableStringFieldUpdateOperationsInput | string | null
    sold?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    shoppingCartId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutBookInput
  }

  export type BookUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    publishYear?: IntFieldUpdateOperationsInput | number
    isbn?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverDataUri?: NullableStringFieldUpdateOperationsInput | string | null
    sold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    publisherId?: StringFieldUpdateOperationsInput | string
    publishYear?: IntFieldUpdateOperationsInput | number
    isbn?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverDataUri?: NullableStringFieldUpdateOperationsInput | string | null
    sold?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    shoppingCartId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthorCreateInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    books?: BookCreateNestedManyWithoutAuthorsInput
  }

  export type AuthorUncheckedCreateInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    books?: BookUpdateManyWithoutAuthorsInput
  }

  export type AuthorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublisherCreateInput = {
    id?: string
    name: string
    city: string
    state: string
    website?: string | null
    book?: BookCreateNestedManyWithoutPublisherInput
  }

  export type PublisherUncheckedCreateInput = {
    id?: string
    name: string
    city: string
    state: string
    website?: string | null
    book?: BookUncheckedCreateNestedManyWithoutPublisherInput
  }

  export type PublisherUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    book?: BookUpdateManyWithoutPublisherInput
  }

  export type PublisherUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    book?: BookUncheckedUpdateManyWithoutPublisherInput
  }

  export type PublisherUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PublisherUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GenreCreateInput = {
    name: string
    books?: BookCreateNestedManyWithoutGenresInput
  }

  export type GenreUncheckedCreateInput = {
    id?: number
    name: string
  }

  export type GenreUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    books?: BookUpdateManyWithoutGenresInput
  }

  export type GenreUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GenreUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GenreUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewCreateInput = {
    id?: string
    value?: number
    description: string
    postedAs?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
    book: BookCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    value?: number
    description: string
    postedAs?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    bookId: string
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    postedAs?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsInput
    book?: BookUpdateOneRequiredWithoutReviewsInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    postedAs?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    postedAs?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    postedAs?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    bookId?: StringFieldUpdateOperationsInput | string
  }

  export type AddressCreateInput = {
    id?: string
    street: string
    apartmentOrUnit?: string | null
    city: string
    state: string
    country: string
    zipcode: string
    userShippingAddress: UserCreateNestedOneWithoutShippingAddressesInput
  }

  export type AddressUncheckedCreateInput = {
    id?: string
    street: string
    apartmentOrUnit?: string | null
    city: string
    state: string
    country: string
    zipcode: string
    userShippingAddressId: string
  }

  export type AddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    apartmentOrUnit?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    userShippingAddress?: UserUpdateOneRequiredWithoutShippingAddressesInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    apartmentOrUnit?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    userShippingAddressId?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    apartmentOrUnit?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    apartmentOrUnit?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
    userShippingAddressId?: StringFieldUpdateOperationsInput | string
  }

  export type TransactionCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
    books?: BookCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    books?: BookUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsInput
    books?: BookUpdateManyWithoutTransactionInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    books?: BookUncheckedUpdateManyWithoutTransactionInput
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditCardCreateInput = {
    id?: string
    encryptedCreditCardNumber: string
    encryptedCCV: string
    lastFourDigits: string
    expirationDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCreditCardsInput
  }

  export type CreditCardUncheckedCreateInput = {
    id?: string
    userId: string
    encryptedCreditCardNumber: string
    encryptedCCV: string
    lastFourDigits: string
    expirationDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreditCardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    encryptedCreditCardNumber?: StringFieldUpdateOperationsInput | string
    encryptedCCV?: StringFieldUpdateOperationsInput | string
    lastFourDigits?: StringFieldUpdateOperationsInput | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCreditCardsInput
  }

  export type CreditCardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    encryptedCreditCardNumber?: StringFieldUpdateOperationsInput | string
    encryptedCCV?: StringFieldUpdateOperationsInput | string
    lastFourDigits?: StringFieldUpdateOperationsInput | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditCardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    encryptedCreditCardNumber?: StringFieldUpdateOperationsInput | string
    encryptedCCV?: StringFieldUpdateOperationsInput | string
    lastFourDigits?: StringFieldUpdateOperationsInput | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditCardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    encryptedCreditCardNumber?: StringFieldUpdateOperationsInput | string
    encryptedCCV?: StringFieldUpdateOperationsInput | string
    lastFourDigits?: StringFieldUpdateOperationsInput | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShoppingCartCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutShoppingCartInput
    books?: BookCreateNestedManyWithoutShoppingCartInput
  }

  export type ShoppingCartUncheckedCreateInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    books?: BookUncheckedCreateNestedManyWithoutShoppingCartInput
  }

  export type ShoppingCartUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutShoppingCartInput
    books?: BookUpdateManyWithoutShoppingCartInput
  }

  export type ShoppingCartUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    books?: BookUncheckedUpdateManyWithoutShoppingCartInput
  }

  export type ShoppingCartUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShoppingCartUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleCreateInput = {
    name: string
    users?: UserCreateNestedManyWithoutRolesInput
  }

  export type RoleUncheckedCreateInput = {
    id?: number
    name: string
  }

  export type RoleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutRolesInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LogCreateInput = {
    id?: string
    name: string
    message: string
    createdAt?: Date | string
  }

  export type LogUncheckedCreateInput = {
    id?: string
    name: string
    message: string
    createdAt?: Date | string
  }

  export type LogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type AddressListRelationFilter = {
    every?: AddressWhereInput
    some?: AddressWhereInput
    none?: AddressWhereInput
  }

  export type CreditCardListRelationFilter = {
    every?: CreditCardWhereInput
    some?: CreditCardWhereInput
    none?: CreditCardWhereInput
  }

  export type RoleListRelationFilter = {
    every?: RoleWhereInput
    some?: RoleWhereInput
    none?: RoleWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type ShoppingCartListRelationFilter = {
    every?: ShoppingCartWhereInput
    some?: ShoppingCartWhereInput
    none?: ShoppingCartWhereInput
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type AuthorListRelationFilter = {
    every?: AuthorWhereInput
    some?: AuthorWhereInput
    none?: AuthorWhereInput
  }

  export type PublisherRelationFilter = {
    is?: PublisherWhereInput
    isNot?: PublisherWhereInput
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type GenreListRelationFilter = {
    every?: GenreWhereInput
    some?: GenreWhereInput
    none?: GenreWhereInput
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type TransactionRelationFilter = {
    is?: TransactionWhereInput | null
    isNot?: TransactionWhereInput | null
  }

  export type ShoppingCartRelationFilter = {
    is?: ShoppingCartWhereInput | null
    isNot?: ShoppingCartWhereInput | null
  }

  export type BookListRelationFilter = {
    every?: BookWhereInput
    some?: BookWhereInput
    none?: BookWhereInput
  }

  export type AuthorFirstNameMiddleNameLastNameCompoundUniqueInput = {
    firstName: string
    middleName: string
    lastName: string
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type BookRelationFilter = {
    is?: BookWhereInput
    isNot?: BookWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutUserInput>, Enumerable<TransactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutUserInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type AddressCreateNestedManyWithoutUserShippingAddressInput = {
    create?: XOR<Enumerable<AddressCreateWithoutUserShippingAddressInput>, Enumerable<AddressUncheckedCreateWithoutUserShippingAddressInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutUserShippingAddressInput>
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type CreditCardCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CreditCardCreateWithoutUserInput>, Enumerable<CreditCardUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CreditCardCreateOrConnectWithoutUserInput>
    connect?: Enumerable<CreditCardWhereUniqueInput>
  }

  export type RoleCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<RoleCreateWithoutUsersInput>, Enumerable<RoleUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutUsersInput>
    connect?: Enumerable<RoleWhereUniqueInput>
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutUserInput>, Enumerable<ReviewUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutUserInput>
    connect?: Enumerable<ReviewWhereUniqueInput>
  }

  export type ShoppingCartCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ShoppingCartCreateWithoutUserInput>, Enumerable<ShoppingCartUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ShoppingCartCreateOrConnectWithoutUserInput>
    connect?: Enumerable<ShoppingCartWhereUniqueInput>
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutUserInput>, Enumerable<TransactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutUserInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
  }

  export type AddressUncheckedCreateNestedManyWithoutUserShippingAddressInput = {
    create?: XOR<Enumerable<AddressCreateWithoutUserShippingAddressInput>, Enumerable<AddressUncheckedCreateWithoutUserShippingAddressInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutUserShippingAddressInput>
    connect?: Enumerable<AddressWhereUniqueInput>
  }

  export type CreditCardUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CreditCardCreateWithoutUserInput>, Enumerable<CreditCardUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CreditCardCreateOrConnectWithoutUserInput>
    connect?: Enumerable<CreditCardWhereUniqueInput>
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutUserInput>, Enumerable<ReviewUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutUserInput>
    connect?: Enumerable<ReviewWhereUniqueInput>
  }

  export type ShoppingCartUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ShoppingCartCreateWithoutUserInput>, Enumerable<ShoppingCartUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ShoppingCartCreateOrConnectWithoutUserInput>
    connect?: Enumerable<ShoppingCartWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TransactionUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutUserInput>, Enumerable<TransactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type AddressUpdateManyWithoutUserShippingAddressInput = {
    create?: XOR<Enumerable<AddressCreateWithoutUserShippingAddressInput>, Enumerable<AddressUncheckedCreateWithoutUserShippingAddressInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutUserShippingAddressInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutUserShippingAddressInput>
    connect?: Enumerable<AddressWhereUniqueInput>
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutUserShippingAddressInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutUserShippingAddressInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type CreditCardUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CreditCardCreateWithoutUserInput>, Enumerable<CreditCardUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CreditCardCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CreditCardUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<CreditCardWhereUniqueInput>
    set?: Enumerable<CreditCardWhereUniqueInput>
    disconnect?: Enumerable<CreditCardWhereUniqueInput>
    delete?: Enumerable<CreditCardWhereUniqueInput>
    update?: Enumerable<CreditCardUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CreditCardUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CreditCardScalarWhereInput>
  }

  export type RoleUpdateManyWithoutUsersInput = {
    create?: XOR<Enumerable<RoleCreateWithoutUsersInput>, Enumerable<RoleUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<RoleCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<RoleUpsertWithWhereUniqueWithoutUsersInput>
    connect?: Enumerable<RoleWhereUniqueInput>
    set?: Enumerable<RoleWhereUniqueInput>
    disconnect?: Enumerable<RoleWhereUniqueInput>
    delete?: Enumerable<RoleWhereUniqueInput>
    update?: Enumerable<RoleUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<RoleUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<RoleScalarWhereInput>
  }

  export type ReviewUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutUserInput>, Enumerable<ReviewUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ReviewUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<ReviewWhereUniqueInput>
    set?: Enumerable<ReviewWhereUniqueInput>
    disconnect?: Enumerable<ReviewWhereUniqueInput>
    delete?: Enumerable<ReviewWhereUniqueInput>
    update?: Enumerable<ReviewUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ReviewUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ReviewScalarWhereInput>
  }

  export type ShoppingCartUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ShoppingCartCreateWithoutUserInput>, Enumerable<ShoppingCartUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ShoppingCartCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ShoppingCartUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<ShoppingCartWhereUniqueInput>
    set?: Enumerable<ShoppingCartWhereUniqueInput>
    disconnect?: Enumerable<ShoppingCartWhereUniqueInput>
    delete?: Enumerable<ShoppingCartWhereUniqueInput>
    update?: Enumerable<ShoppingCartUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ShoppingCartUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ShoppingCartScalarWhereInput>
  }

  export type TransactionUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<TransactionCreateWithoutUserInput>, Enumerable<TransactionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<TransactionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<TransactionUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<TransactionWhereUniqueInput>
    set?: Enumerable<TransactionWhereUniqueInput>
    disconnect?: Enumerable<TransactionWhereUniqueInput>
    delete?: Enumerable<TransactionWhereUniqueInput>
    update?: Enumerable<TransactionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<TransactionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<TransactionScalarWhereInput>
  }

  export type AddressUncheckedUpdateManyWithoutUserShippingAddressInput = {
    create?: XOR<Enumerable<AddressCreateWithoutUserShippingAddressInput>, Enumerable<AddressUncheckedCreateWithoutUserShippingAddressInput>>
    connectOrCreate?: Enumerable<AddressCreateOrConnectWithoutUserShippingAddressInput>
    upsert?: Enumerable<AddressUpsertWithWhereUniqueWithoutUserShippingAddressInput>
    connect?: Enumerable<AddressWhereUniqueInput>
    set?: Enumerable<AddressWhereUniqueInput>
    disconnect?: Enumerable<AddressWhereUniqueInput>
    delete?: Enumerable<AddressWhereUniqueInput>
    update?: Enumerable<AddressUpdateWithWhereUniqueWithoutUserShippingAddressInput>
    updateMany?: Enumerable<AddressUpdateManyWithWhereWithoutUserShippingAddressInput>
    deleteMany?: Enumerable<AddressScalarWhereInput>
  }

  export type CreditCardUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<CreditCardCreateWithoutUserInput>, Enumerable<CreditCardUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CreditCardCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CreditCardUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<CreditCardWhereUniqueInput>
    set?: Enumerable<CreditCardWhereUniqueInput>
    disconnect?: Enumerable<CreditCardWhereUniqueInput>
    delete?: Enumerable<CreditCardWhereUniqueInput>
    update?: Enumerable<CreditCardUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CreditCardUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CreditCardScalarWhereInput>
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutUserInput>, Enumerable<ReviewUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ReviewUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<ReviewWhereUniqueInput>
    set?: Enumerable<ReviewWhereUniqueInput>
    disconnect?: Enumerable<ReviewWhereUniqueInput>
    delete?: Enumerable<ReviewWhereUniqueInput>
    update?: Enumerable<ReviewUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ReviewUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ReviewScalarWhereInput>
  }

  export type ShoppingCartUncheckedUpdateManyWithoutUserInput = {
    create?: XOR<Enumerable<ShoppingCartCreateWithoutUserInput>, Enumerable<ShoppingCartUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ShoppingCartCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ShoppingCartUpsertWithWhereUniqueWithoutUserInput>
    connect?: Enumerable<ShoppingCartWhereUniqueInput>
    set?: Enumerable<ShoppingCartWhereUniqueInput>
    disconnect?: Enumerable<ShoppingCartWhereUniqueInput>
    delete?: Enumerable<ShoppingCartWhereUniqueInput>
    update?: Enumerable<ShoppingCartUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ShoppingCartUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ShoppingCartScalarWhereInput>
  }

  export type AuthorCreateNestedManyWithoutBooksInput = {
    create?: XOR<Enumerable<AuthorCreateWithoutBooksInput>, Enumerable<AuthorUncheckedCreateWithoutBooksInput>>
    connectOrCreate?: Enumerable<AuthorCreateOrConnectWithoutBooksInput>
    connect?: Enumerable<AuthorWhereUniqueInput>
  }

  export type PublisherCreateNestedOneWithoutBookInput = {
    create?: XOR<PublisherCreateWithoutBookInput, PublisherUncheckedCreateWithoutBookInput>
    connectOrCreate?: PublisherCreateOrConnectWithoutBookInput
    connect?: PublisherWhereUniqueInput
  }

  export type GenreCreateNestedManyWithoutBooksInput = {
    create?: XOR<Enumerable<GenreCreateWithoutBooksInput>, Enumerable<GenreUncheckedCreateWithoutBooksInput>>
    connectOrCreate?: Enumerable<GenreCreateOrConnectWithoutBooksInput>
    connect?: Enumerable<GenreWhereUniqueInput>
  }

  export type ReviewCreateNestedManyWithoutBookInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutBookInput>, Enumerable<ReviewUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutBookInput>
    connect?: Enumerable<ReviewWhereUniqueInput>
  }

  export type TransactionCreateNestedOneWithoutBooksInput = {
    create?: XOR<TransactionCreateWithoutBooksInput, TransactionUncheckedCreateWithoutBooksInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutBooksInput
    connect?: TransactionWhereUniqueInput
  }

  export type ShoppingCartCreateNestedOneWithoutBooksInput = {
    create?: XOR<ShoppingCartCreateWithoutBooksInput, ShoppingCartUncheckedCreateWithoutBooksInput>
    connectOrCreate?: ShoppingCartCreateOrConnectWithoutBooksInput
    connect?: ShoppingCartWhereUniqueInput
  }

  export type ReviewUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutBookInput>, Enumerable<ReviewUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutBookInput>
    connect?: Enumerable<ReviewWhereUniqueInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AuthorUpdateManyWithoutBooksInput = {
    create?: XOR<Enumerable<AuthorCreateWithoutBooksInput>, Enumerable<AuthorUncheckedCreateWithoutBooksInput>>
    connectOrCreate?: Enumerable<AuthorCreateOrConnectWithoutBooksInput>
    upsert?: Enumerable<AuthorUpsertWithWhereUniqueWithoutBooksInput>
    connect?: Enumerable<AuthorWhereUniqueInput>
    set?: Enumerable<AuthorWhereUniqueInput>
    disconnect?: Enumerable<AuthorWhereUniqueInput>
    delete?: Enumerable<AuthorWhereUniqueInput>
    update?: Enumerable<AuthorUpdateWithWhereUniqueWithoutBooksInput>
    updateMany?: Enumerable<AuthorUpdateManyWithWhereWithoutBooksInput>
    deleteMany?: Enumerable<AuthorScalarWhereInput>
  }

  export type PublisherUpdateOneRequiredWithoutBookInput = {
    create?: XOR<PublisherCreateWithoutBookInput, PublisherUncheckedCreateWithoutBookInput>
    connectOrCreate?: PublisherCreateOrConnectWithoutBookInput
    upsert?: PublisherUpsertWithoutBookInput
    connect?: PublisherWhereUniqueInput
    update?: XOR<PublisherUpdateWithoutBookInput, PublisherUncheckedUpdateWithoutBookInput>
  }

  export type GenreUpdateManyWithoutBooksInput = {
    create?: XOR<Enumerable<GenreCreateWithoutBooksInput>, Enumerable<GenreUncheckedCreateWithoutBooksInput>>
    connectOrCreate?: Enumerable<GenreCreateOrConnectWithoutBooksInput>
    upsert?: Enumerable<GenreUpsertWithWhereUniqueWithoutBooksInput>
    connect?: Enumerable<GenreWhereUniqueInput>
    set?: Enumerable<GenreWhereUniqueInput>
    disconnect?: Enumerable<GenreWhereUniqueInput>
    delete?: Enumerable<GenreWhereUniqueInput>
    update?: Enumerable<GenreUpdateWithWhereUniqueWithoutBooksInput>
    updateMany?: Enumerable<GenreUpdateManyWithWhereWithoutBooksInput>
    deleteMany?: Enumerable<GenreScalarWhereInput>
  }

  export type ReviewUpdateManyWithoutBookInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutBookInput>, Enumerable<ReviewUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutBookInput>
    upsert?: Enumerable<ReviewUpsertWithWhereUniqueWithoutBookInput>
    connect?: Enumerable<ReviewWhereUniqueInput>
    set?: Enumerable<ReviewWhereUniqueInput>
    disconnect?: Enumerable<ReviewWhereUniqueInput>
    delete?: Enumerable<ReviewWhereUniqueInput>
    update?: Enumerable<ReviewUpdateWithWhereUniqueWithoutBookInput>
    updateMany?: Enumerable<ReviewUpdateManyWithWhereWithoutBookInput>
    deleteMany?: Enumerable<ReviewScalarWhereInput>
  }

  export type TransactionUpdateOneWithoutBooksInput = {
    create?: XOR<TransactionCreateWithoutBooksInput, TransactionUncheckedCreateWithoutBooksInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutBooksInput
    upsert?: TransactionUpsertWithoutBooksInput
    connect?: TransactionWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<TransactionUpdateWithoutBooksInput, TransactionUncheckedUpdateWithoutBooksInput>
  }

  export type ShoppingCartUpdateOneWithoutBooksInput = {
    create?: XOR<ShoppingCartCreateWithoutBooksInput, ShoppingCartUncheckedCreateWithoutBooksInput>
    connectOrCreate?: ShoppingCartCreateOrConnectWithoutBooksInput
    upsert?: ShoppingCartUpsertWithoutBooksInput
    connect?: ShoppingCartWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ShoppingCartUpdateWithoutBooksInput, ShoppingCartUncheckedUpdateWithoutBooksInput>
  }

  export type ReviewUncheckedUpdateManyWithoutBookInput = {
    create?: XOR<Enumerable<ReviewCreateWithoutBookInput>, Enumerable<ReviewUncheckedCreateWithoutBookInput>>
    connectOrCreate?: Enumerable<ReviewCreateOrConnectWithoutBookInput>
    upsert?: Enumerable<ReviewUpsertWithWhereUniqueWithoutBookInput>
    connect?: Enumerable<ReviewWhereUniqueInput>
    set?: Enumerable<ReviewWhereUniqueInput>
    disconnect?: Enumerable<ReviewWhereUniqueInput>
    delete?: Enumerable<ReviewWhereUniqueInput>
    update?: Enumerable<ReviewUpdateWithWhereUniqueWithoutBookInput>
    updateMany?: Enumerable<ReviewUpdateManyWithWhereWithoutBookInput>
    deleteMany?: Enumerable<ReviewScalarWhereInput>
  }

  export type BookCreateNestedManyWithoutAuthorsInput = {
    create?: XOR<Enumerable<BookCreateWithoutAuthorsInput>, Enumerable<BookUncheckedCreateWithoutAuthorsInput>>
    connectOrCreate?: Enumerable<BookCreateOrConnectWithoutAuthorsInput>
    connect?: Enumerable<BookWhereUniqueInput>
  }

  export type BookUpdateManyWithoutAuthorsInput = {
    create?: XOR<Enumerable<BookCreateWithoutAuthorsInput>, Enumerable<BookUncheckedCreateWithoutAuthorsInput>>
    connectOrCreate?: Enumerable<BookCreateOrConnectWithoutAuthorsInput>
    upsert?: Enumerable<BookUpsertWithWhereUniqueWithoutAuthorsInput>
    connect?: Enumerable<BookWhereUniqueInput>
    set?: Enumerable<BookWhereUniqueInput>
    disconnect?: Enumerable<BookWhereUniqueInput>
    delete?: Enumerable<BookWhereUniqueInput>
    update?: Enumerable<BookUpdateWithWhereUniqueWithoutAuthorsInput>
    updateMany?: Enumerable<BookUpdateManyWithWhereWithoutAuthorsInput>
    deleteMany?: Enumerable<BookScalarWhereInput>
  }

  export type BookCreateNestedManyWithoutPublisherInput = {
    create?: XOR<Enumerable<BookCreateWithoutPublisherInput>, Enumerable<BookUncheckedCreateWithoutPublisherInput>>
    connectOrCreate?: Enumerable<BookCreateOrConnectWithoutPublisherInput>
    connect?: Enumerable<BookWhereUniqueInput>
  }

  export type BookUncheckedCreateNestedManyWithoutPublisherInput = {
    create?: XOR<Enumerable<BookCreateWithoutPublisherInput>, Enumerable<BookUncheckedCreateWithoutPublisherInput>>
    connectOrCreate?: Enumerable<BookCreateOrConnectWithoutPublisherInput>
    connect?: Enumerable<BookWhereUniqueInput>
  }

  export type BookUpdateManyWithoutPublisherInput = {
    create?: XOR<Enumerable<BookCreateWithoutPublisherInput>, Enumerable<BookUncheckedCreateWithoutPublisherInput>>
    connectOrCreate?: Enumerable<BookCreateOrConnectWithoutPublisherInput>
    upsert?: Enumerable<BookUpsertWithWhereUniqueWithoutPublisherInput>
    connect?: Enumerable<BookWhereUniqueInput>
    set?: Enumerable<BookWhereUniqueInput>
    disconnect?: Enumerable<BookWhereUniqueInput>
    delete?: Enumerable<BookWhereUniqueInput>
    update?: Enumerable<BookUpdateWithWhereUniqueWithoutPublisherInput>
    updateMany?: Enumerable<BookUpdateManyWithWhereWithoutPublisherInput>
    deleteMany?: Enumerable<BookScalarWhereInput>
  }

  export type BookUncheckedUpdateManyWithoutPublisherInput = {
    create?: XOR<Enumerable<BookCreateWithoutPublisherInput>, Enumerable<BookUncheckedCreateWithoutPublisherInput>>
    connectOrCreate?: Enumerable<BookCreateOrConnectWithoutPublisherInput>
    upsert?: Enumerable<BookUpsertWithWhereUniqueWithoutPublisherInput>
    connect?: Enumerable<BookWhereUniqueInput>
    set?: Enumerable<BookWhereUniqueInput>
    disconnect?: Enumerable<BookWhereUniqueInput>
    delete?: Enumerable<BookWhereUniqueInput>
    update?: Enumerable<BookUpdateWithWhereUniqueWithoutPublisherInput>
    updateMany?: Enumerable<BookUpdateManyWithWhereWithoutPublisherInput>
    deleteMany?: Enumerable<BookScalarWhereInput>
  }

  export type BookCreateNestedManyWithoutGenresInput = {
    create?: XOR<Enumerable<BookCreateWithoutGenresInput>, Enumerable<BookUncheckedCreateWithoutGenresInput>>
    connectOrCreate?: Enumerable<BookCreateOrConnectWithoutGenresInput>
    connect?: Enumerable<BookWhereUniqueInput>
  }

  export type BookUpdateManyWithoutGenresInput = {
    create?: XOR<Enumerable<BookCreateWithoutGenresInput>, Enumerable<BookUncheckedCreateWithoutGenresInput>>
    connectOrCreate?: Enumerable<BookCreateOrConnectWithoutGenresInput>
    upsert?: Enumerable<BookUpsertWithWhereUniqueWithoutGenresInput>
    connect?: Enumerable<BookWhereUniqueInput>
    set?: Enumerable<BookWhereUniqueInput>
    disconnect?: Enumerable<BookWhereUniqueInput>
    delete?: Enumerable<BookWhereUniqueInput>
    update?: Enumerable<BookUpdateWithWhereUniqueWithoutGenresInput>
    updateMany?: Enumerable<BookUpdateManyWithWhereWithoutGenresInput>
    deleteMany?: Enumerable<BookScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type BookCreateNestedOneWithoutReviewsInput = {
    create?: XOR<BookCreateWithoutReviewsInput, BookUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: BookCreateOrConnectWithoutReviewsInput
    connect?: BookWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type BookUpdateOneRequiredWithoutReviewsInput = {
    create?: XOR<BookCreateWithoutReviewsInput, BookUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: BookCreateOrConnectWithoutReviewsInput
    upsert?: BookUpsertWithoutReviewsInput
    connect?: BookWhereUniqueInput
    update?: XOR<BookUpdateWithoutReviewsInput, BookUncheckedUpdateWithoutReviewsInput>
  }

  export type UserCreateNestedOneWithoutShippingAddressesInput = {
    create?: XOR<UserCreateWithoutShippingAddressesInput, UserUncheckedCreateWithoutShippingAddressesInput>
    connectOrCreate?: UserCreateOrConnectWithoutShippingAddressesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutShippingAddressesInput = {
    create?: XOR<UserCreateWithoutShippingAddressesInput, UserUncheckedCreateWithoutShippingAddressesInput>
    connectOrCreate?: UserCreateOrConnectWithoutShippingAddressesInput
    upsert?: UserUpsertWithoutShippingAddressesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutShippingAddressesInput, UserUncheckedUpdateWithoutShippingAddressesInput>
  }

  export type UserCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type BookCreateNestedManyWithoutTransactionInput = {
    create?: XOR<Enumerable<BookCreateWithoutTransactionInput>, Enumerable<BookUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<BookCreateOrConnectWithoutTransactionInput>
    connect?: Enumerable<BookWhereUniqueInput>
  }

  export type BookUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<Enumerable<BookCreateWithoutTransactionInput>, Enumerable<BookUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<BookCreateOrConnectWithoutTransactionInput>
    connect?: Enumerable<BookWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutTransactionsInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    upsert?: UserUpsertWithoutTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type BookUpdateManyWithoutTransactionInput = {
    create?: XOR<Enumerable<BookCreateWithoutTransactionInput>, Enumerable<BookUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<BookCreateOrConnectWithoutTransactionInput>
    upsert?: Enumerable<BookUpsertWithWhereUniqueWithoutTransactionInput>
    connect?: Enumerable<BookWhereUniqueInput>
    set?: Enumerable<BookWhereUniqueInput>
    disconnect?: Enumerable<BookWhereUniqueInput>
    delete?: Enumerable<BookWhereUniqueInput>
    update?: Enumerable<BookUpdateWithWhereUniqueWithoutTransactionInput>
    updateMany?: Enumerable<BookUpdateManyWithWhereWithoutTransactionInput>
    deleteMany?: Enumerable<BookScalarWhereInput>
  }

  export type BookUncheckedUpdateManyWithoutTransactionInput = {
    create?: XOR<Enumerable<BookCreateWithoutTransactionInput>, Enumerable<BookUncheckedCreateWithoutTransactionInput>>
    connectOrCreate?: Enumerable<BookCreateOrConnectWithoutTransactionInput>
    upsert?: Enumerable<BookUpsertWithWhereUniqueWithoutTransactionInput>
    connect?: Enumerable<BookWhereUniqueInput>
    set?: Enumerable<BookWhereUniqueInput>
    disconnect?: Enumerable<BookWhereUniqueInput>
    delete?: Enumerable<BookWhereUniqueInput>
    update?: Enumerable<BookUpdateWithWhereUniqueWithoutTransactionInput>
    updateMany?: Enumerable<BookUpdateManyWithWhereWithoutTransactionInput>
    deleteMany?: Enumerable<BookScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutCreditCardsInput = {
    create?: XOR<UserCreateWithoutCreditCardsInput, UserUncheckedCreateWithoutCreditCardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreditCardsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCreditCardsInput = {
    create?: XOR<UserCreateWithoutCreditCardsInput, UserUncheckedCreateWithoutCreditCardsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreditCardsInput
    upsert?: UserUpsertWithoutCreditCardsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCreditCardsInput, UserUncheckedUpdateWithoutCreditCardsInput>
  }

  export type UserCreateNestedOneWithoutShoppingCartInput = {
    create?: XOR<UserCreateWithoutShoppingCartInput, UserUncheckedCreateWithoutShoppingCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutShoppingCartInput
    connect?: UserWhereUniqueInput
  }

  export type BookCreateNestedManyWithoutShoppingCartInput = {
    create?: XOR<Enumerable<BookCreateWithoutShoppingCartInput>, Enumerable<BookUncheckedCreateWithoutShoppingCartInput>>
    connectOrCreate?: Enumerable<BookCreateOrConnectWithoutShoppingCartInput>
    connect?: Enumerable<BookWhereUniqueInput>
  }

  export type BookUncheckedCreateNestedManyWithoutShoppingCartInput = {
    create?: XOR<Enumerable<BookCreateWithoutShoppingCartInput>, Enumerable<BookUncheckedCreateWithoutShoppingCartInput>>
    connectOrCreate?: Enumerable<BookCreateOrConnectWithoutShoppingCartInput>
    connect?: Enumerable<BookWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutShoppingCartInput = {
    create?: XOR<UserCreateWithoutShoppingCartInput, UserUncheckedCreateWithoutShoppingCartInput>
    connectOrCreate?: UserCreateOrConnectWithoutShoppingCartInput
    upsert?: UserUpsertWithoutShoppingCartInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutShoppingCartInput, UserUncheckedUpdateWithoutShoppingCartInput>
  }

  export type BookUpdateManyWithoutShoppingCartInput = {
    create?: XOR<Enumerable<BookCreateWithoutShoppingCartInput>, Enumerable<BookUncheckedCreateWithoutShoppingCartInput>>
    connectOrCreate?: Enumerable<BookCreateOrConnectWithoutShoppingCartInput>
    upsert?: Enumerable<BookUpsertWithWhereUniqueWithoutShoppingCartInput>
    connect?: Enumerable<BookWhereUniqueInput>
    set?: Enumerable<BookWhereUniqueInput>
    disconnect?: Enumerable<BookWhereUniqueInput>
    delete?: Enumerable<BookWhereUniqueInput>
    update?: Enumerable<BookUpdateWithWhereUniqueWithoutShoppingCartInput>
    updateMany?: Enumerable<BookUpdateManyWithWhereWithoutShoppingCartInput>
    deleteMany?: Enumerable<BookScalarWhereInput>
  }

  export type BookUncheckedUpdateManyWithoutShoppingCartInput = {
    create?: XOR<Enumerable<BookCreateWithoutShoppingCartInput>, Enumerable<BookUncheckedCreateWithoutShoppingCartInput>>
    connectOrCreate?: Enumerable<BookCreateOrConnectWithoutShoppingCartInput>
    upsert?: Enumerable<BookUpsertWithWhereUniqueWithoutShoppingCartInput>
    connect?: Enumerable<BookWhereUniqueInput>
    set?: Enumerable<BookWhereUniqueInput>
    disconnect?: Enumerable<BookWhereUniqueInput>
    delete?: Enumerable<BookWhereUniqueInput>
    update?: Enumerable<BookUpdateWithWhereUniqueWithoutShoppingCartInput>
    updateMany?: Enumerable<BookUpdateManyWithWhereWithoutShoppingCartInput>
    deleteMany?: Enumerable<BookScalarWhereInput>
  }

  export type UserCreateNestedManyWithoutRolesInput = {
    create?: XOR<Enumerable<UserCreateWithoutRolesInput>, Enumerable<UserUncheckedCreateWithoutRolesInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRolesInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserUpdateManyWithoutRolesInput = {
    create?: XOR<Enumerable<UserCreateWithoutRolesInput>, Enumerable<UserUncheckedCreateWithoutRolesInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutRolesInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutRolesInput>
    connect?: Enumerable<UserWhereUniqueInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutRolesInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutRolesInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type TransactionCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    books?: BookCreateNestedManyWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    books?: BookUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type AddressCreateWithoutUserShippingAddressInput = {
    id?: string
    street: string
    apartmentOrUnit?: string | null
    city: string
    state: string
    country: string
    zipcode: string
  }

  export type AddressUncheckedCreateWithoutUserShippingAddressInput = {
    id?: string
    street: string
    apartmentOrUnit?: string | null
    city: string
    state: string
    country: string
    zipcode: string
  }

  export type AddressCreateOrConnectWithoutUserShippingAddressInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutUserShippingAddressInput, AddressUncheckedCreateWithoutUserShippingAddressInput>
  }

  export type CreditCardCreateWithoutUserInput = {
    id?: string
    encryptedCreditCardNumber: string
    encryptedCCV: string
    lastFourDigits: string
    expirationDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreditCardUncheckedCreateWithoutUserInput = {
    id?: string
    encryptedCreditCardNumber: string
    encryptedCCV: string
    lastFourDigits: string
    expirationDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreditCardCreateOrConnectWithoutUserInput = {
    where: CreditCardWhereUniqueInput
    create: XOR<CreditCardCreateWithoutUserInput, CreditCardUncheckedCreateWithoutUserInput>
  }

  export type RoleCreateWithoutUsersInput = {
    name: string
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type ReviewCreateWithoutUserInput = {
    id?: string
    value?: number
    description: string
    postedAs?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    book: BookCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: string
    value?: number
    description: string
    postedAs?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookId: string
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ShoppingCartCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    books?: BookCreateNestedManyWithoutShoppingCartInput
  }

  export type ShoppingCartUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    books?: BookUncheckedCreateNestedManyWithoutShoppingCartInput
  }

  export type ShoppingCartCreateOrConnectWithoutUserInput = {
    where: ShoppingCartWhereUniqueInput
    create: XOR<ShoppingCartCreateWithoutUserInput, ShoppingCartUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutTransactionsInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: Enumerable<TransactionScalarWhereInput>
    OR?: Enumerable<TransactionScalarWhereInput>
    NOT?: Enumerable<TransactionScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type AddressUpsertWithWhereUniqueWithoutUserShippingAddressInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutUserShippingAddressInput, AddressUncheckedUpdateWithoutUserShippingAddressInput>
    create: XOR<AddressCreateWithoutUserShippingAddressInput, AddressUncheckedCreateWithoutUserShippingAddressInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutUserShippingAddressInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutUserShippingAddressInput, AddressUncheckedUpdateWithoutUserShippingAddressInput>
  }

  export type AddressUpdateManyWithWhereWithoutUserShippingAddressInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutShippingAddressesInput>
  }

  export type AddressScalarWhereInput = {
    AND?: Enumerable<AddressScalarWhereInput>
    OR?: Enumerable<AddressScalarWhereInput>
    NOT?: Enumerable<AddressScalarWhereInput>
    id?: StringFilter | string
    street?: StringFilter | string
    apartmentOrUnit?: StringNullableFilter | string | null
    city?: StringFilter | string
    state?: StringFilter | string
    country?: StringFilter | string
    zipcode?: StringFilter | string
    userShippingAddressId?: StringFilter | string
  }

  export type CreditCardUpsertWithWhereUniqueWithoutUserInput = {
    where: CreditCardWhereUniqueInput
    update: XOR<CreditCardUpdateWithoutUserInput, CreditCardUncheckedUpdateWithoutUserInput>
    create: XOR<CreditCardCreateWithoutUserInput, CreditCardUncheckedCreateWithoutUserInput>
  }

  export type CreditCardUpdateWithWhereUniqueWithoutUserInput = {
    where: CreditCardWhereUniqueInput
    data: XOR<CreditCardUpdateWithoutUserInput, CreditCardUncheckedUpdateWithoutUserInput>
  }

  export type CreditCardUpdateManyWithWhereWithoutUserInput = {
    where: CreditCardScalarWhereInput
    data: XOR<CreditCardUpdateManyMutationInput, CreditCardUncheckedUpdateManyWithoutCreditCardsInput>
  }

  export type CreditCardScalarWhereInput = {
    AND?: Enumerable<CreditCardScalarWhereInput>
    OR?: Enumerable<CreditCardScalarWhereInput>
    NOT?: Enumerable<CreditCardScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    encryptedCreditCardNumber?: StringFilter | string
    encryptedCCV?: StringFilter | string
    lastFourDigits?: StringFilter | string
    expirationDate?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type RoleUpsertWithWhereUniqueWithoutUsersInput = {
    where: RoleWhereUniqueInput
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type RoleUpdateWithWhereUniqueWithoutUsersInput = {
    where: RoleWhereUniqueInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateManyWithWhereWithoutUsersInput = {
    where: RoleScalarWhereInput
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyWithoutRolesInput>
  }

  export type RoleScalarWhereInput = {
    AND?: Enumerable<RoleScalarWhereInput>
    OR?: Enumerable<RoleScalarWhereInput>
    NOT?: Enumerable<RoleScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutReviewsInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: Enumerable<ReviewScalarWhereInput>
    OR?: Enumerable<ReviewScalarWhereInput>
    NOT?: Enumerable<ReviewScalarWhereInput>
    id?: StringFilter | string
    value?: IntFilter | number
    description?: StringFilter | string
    postedAs?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    userId?: StringFilter | string
    bookId?: StringFilter | string
  }

  export type ShoppingCartUpsertWithWhereUniqueWithoutUserInput = {
    where: ShoppingCartWhereUniqueInput
    update: XOR<ShoppingCartUpdateWithoutUserInput, ShoppingCartUncheckedUpdateWithoutUserInput>
    create: XOR<ShoppingCartCreateWithoutUserInput, ShoppingCartUncheckedCreateWithoutUserInput>
  }

  export type ShoppingCartUpdateWithWhereUniqueWithoutUserInput = {
    where: ShoppingCartWhereUniqueInput
    data: XOR<ShoppingCartUpdateWithoutUserInput, ShoppingCartUncheckedUpdateWithoutUserInput>
  }

  export type ShoppingCartUpdateManyWithWhereWithoutUserInput = {
    where: ShoppingCartScalarWhereInput
    data: XOR<ShoppingCartUpdateManyMutationInput, ShoppingCartUncheckedUpdateManyWithoutShoppingCartInput>
  }

  export type ShoppingCartScalarWhereInput = {
    AND?: Enumerable<ShoppingCartScalarWhereInput>
    OR?: Enumerable<ShoppingCartScalarWhereInput>
    NOT?: Enumerable<ShoppingCartScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type AuthorCreateWithoutBooksInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthorUncheckedCreateWithoutBooksInput = {
    id?: string
    firstName: string
    middleName?: string | null
    lastName: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthorCreateOrConnectWithoutBooksInput = {
    where: AuthorWhereUniqueInput
    create: XOR<AuthorCreateWithoutBooksInput, AuthorUncheckedCreateWithoutBooksInput>
  }

  export type PublisherCreateWithoutBookInput = {
    id?: string
    name: string
    city: string
    state: string
    website?: string | null
  }

  export type PublisherUncheckedCreateWithoutBookInput = {
    id?: string
    name: string
    city: string
    state: string
    website?: string | null
  }

  export type PublisherCreateOrConnectWithoutBookInput = {
    where: PublisherWhereUniqueInput
    create: XOR<PublisherCreateWithoutBookInput, PublisherUncheckedCreateWithoutBookInput>
  }

  export type GenreCreateWithoutBooksInput = {
    name: string
  }

  export type GenreUncheckedCreateWithoutBooksInput = {
    id?: number
    name: string
  }

  export type GenreCreateOrConnectWithoutBooksInput = {
    where: GenreWhereUniqueInput
    create: XOR<GenreCreateWithoutBooksInput, GenreUncheckedCreateWithoutBooksInput>
  }

  export type ReviewCreateWithoutBookInput = {
    id?: string
    value?: number
    description: string
    postedAs?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutBookInput = {
    id?: string
    value?: number
    description: string
    postedAs?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
  }

  export type ReviewCreateOrConnectWithoutBookInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutBookInput, ReviewUncheckedCreateWithoutBookInput>
  }

  export type TransactionCreateWithoutBooksInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutBooksInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateOrConnectWithoutBooksInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutBooksInput, TransactionUncheckedCreateWithoutBooksInput>
  }

  export type ShoppingCartCreateWithoutBooksInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutShoppingCartInput
  }

  export type ShoppingCartUncheckedCreateWithoutBooksInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShoppingCartCreateOrConnectWithoutBooksInput = {
    where: ShoppingCartWhereUniqueInput
    create: XOR<ShoppingCartCreateWithoutBooksInput, ShoppingCartUncheckedCreateWithoutBooksInput>
  }

  export type AuthorUpsertWithWhereUniqueWithoutBooksInput = {
    where: AuthorWhereUniqueInput
    update: XOR<AuthorUpdateWithoutBooksInput, AuthorUncheckedUpdateWithoutBooksInput>
    create: XOR<AuthorCreateWithoutBooksInput, AuthorUncheckedCreateWithoutBooksInput>
  }

  export type AuthorUpdateWithWhereUniqueWithoutBooksInput = {
    where: AuthorWhereUniqueInput
    data: XOR<AuthorUpdateWithoutBooksInput, AuthorUncheckedUpdateWithoutBooksInput>
  }

  export type AuthorUpdateManyWithWhereWithoutBooksInput = {
    where: AuthorScalarWhereInput
    data: XOR<AuthorUpdateManyMutationInput, AuthorUncheckedUpdateManyWithoutAuthorsInput>
  }

  export type AuthorScalarWhereInput = {
    AND?: Enumerable<AuthorScalarWhereInput>
    OR?: Enumerable<AuthorScalarWhereInput>
    NOT?: Enumerable<AuthorScalarWhereInput>
    id?: StringFilter | string
    firstName?: StringFilter | string
    middleName?: StringNullableFilter | string | null
    lastName?: StringFilter | string
    description?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type PublisherUpsertWithoutBookInput = {
    update: XOR<PublisherUpdateWithoutBookInput, PublisherUncheckedUpdateWithoutBookInput>
    create: XOR<PublisherCreateWithoutBookInput, PublisherUncheckedCreateWithoutBookInput>
  }

  export type PublisherUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PublisherUncheckedUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GenreUpsertWithWhereUniqueWithoutBooksInput = {
    where: GenreWhereUniqueInput
    update: XOR<GenreUpdateWithoutBooksInput, GenreUncheckedUpdateWithoutBooksInput>
    create: XOR<GenreCreateWithoutBooksInput, GenreUncheckedCreateWithoutBooksInput>
  }

  export type GenreUpdateWithWhereUniqueWithoutBooksInput = {
    where: GenreWhereUniqueInput
    data: XOR<GenreUpdateWithoutBooksInput, GenreUncheckedUpdateWithoutBooksInput>
  }

  export type GenreUpdateManyWithWhereWithoutBooksInput = {
    where: GenreScalarWhereInput
    data: XOR<GenreUpdateManyMutationInput, GenreUncheckedUpdateManyWithoutGenresInput>
  }

  export type GenreScalarWhereInput = {
    AND?: Enumerable<GenreScalarWhereInput>
    OR?: Enumerable<GenreScalarWhereInput>
    NOT?: Enumerable<GenreScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutBookInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutBookInput, ReviewUncheckedUpdateWithoutBookInput>
    create: XOR<ReviewCreateWithoutBookInput, ReviewUncheckedCreateWithoutBookInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutBookInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutBookInput, ReviewUncheckedUpdateWithoutBookInput>
  }

  export type ReviewUpdateManyWithWhereWithoutBookInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutReviewsInput>
  }

  export type TransactionUpsertWithoutBooksInput = {
    update: XOR<TransactionUpdateWithoutBooksInput, TransactionUncheckedUpdateWithoutBooksInput>
    create: XOR<TransactionCreateWithoutBooksInput, TransactionUncheckedCreateWithoutBooksInput>
  }

  export type TransactionUpdateWithoutBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsInput
  }

  export type TransactionUncheckedUpdateWithoutBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShoppingCartUpsertWithoutBooksInput = {
    update: XOR<ShoppingCartUpdateWithoutBooksInput, ShoppingCartUncheckedUpdateWithoutBooksInput>
    create: XOR<ShoppingCartCreateWithoutBooksInput, ShoppingCartUncheckedCreateWithoutBooksInput>
  }

  export type ShoppingCartUpdateWithoutBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutShoppingCartInput
  }

  export type ShoppingCartUncheckedUpdateWithoutBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookCreateWithoutAuthorsInput = {
    id?: string
    title: string
    publishYear: number
    isbn: number
    description: string
    price: number
    coverUrl?: string | null
    coverDataUri?: string | null
    sold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publisher: PublisherCreateNestedOneWithoutBookInput
    genres?: GenreCreateNestedManyWithoutBooksInput
    reviews?: ReviewCreateNestedManyWithoutBookInput
    transaction?: TransactionCreateNestedOneWithoutBooksInput
    shoppingCart?: ShoppingCartCreateNestedOneWithoutBooksInput
  }

  export type BookUncheckedCreateWithoutAuthorsInput = {
    id?: string
    title: string
    publisherId: string
    publishYear: number
    isbn: number
    description: string
    price: number
    coverUrl?: string | null
    coverDataUri?: string | null
    sold?: number
    transactionId?: string | null
    shoppingCartId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookInput
  }

  export type BookCreateOrConnectWithoutAuthorsInput = {
    where: BookWhereUniqueInput
    create: XOR<BookCreateWithoutAuthorsInput, BookUncheckedCreateWithoutAuthorsInput>
  }

  export type BookUpsertWithWhereUniqueWithoutAuthorsInput = {
    where: BookWhereUniqueInput
    update: XOR<BookUpdateWithoutAuthorsInput, BookUncheckedUpdateWithoutAuthorsInput>
    create: XOR<BookCreateWithoutAuthorsInput, BookUncheckedCreateWithoutAuthorsInput>
  }

  export type BookUpdateWithWhereUniqueWithoutAuthorsInput = {
    where: BookWhereUniqueInput
    data: XOR<BookUpdateWithoutAuthorsInput, BookUncheckedUpdateWithoutAuthorsInput>
  }

  export type BookUpdateManyWithWhereWithoutAuthorsInput = {
    where: BookScalarWhereInput
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyWithoutBooksInput>
  }

  export type BookScalarWhereInput = {
    AND?: Enumerable<BookScalarWhereInput>
    OR?: Enumerable<BookScalarWhereInput>
    NOT?: Enumerable<BookScalarWhereInput>
    id?: StringFilter | string
    title?: StringFilter | string
    publisherId?: StringFilter | string
    publishYear?: IntFilter | number
    isbn?: IntFilter | number
    description?: StringFilter | string
    price?: FloatFilter | number
    coverUrl?: StringNullableFilter | string | null
    coverDataUri?: StringNullableFilter | string | null
    sold?: IntFilter | number
    transactionId?: StringNullableFilter | string | null
    shoppingCartId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BookCreateWithoutPublisherInput = {
    id?: string
    title: string
    publishYear: number
    isbn: number
    description: string
    price: number
    coverUrl?: string | null
    coverDataUri?: string | null
    sold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authors?: AuthorCreateNestedManyWithoutBooksInput
    genres?: GenreCreateNestedManyWithoutBooksInput
    reviews?: ReviewCreateNestedManyWithoutBookInput
    transaction?: TransactionCreateNestedOneWithoutBooksInput
    shoppingCart?: ShoppingCartCreateNestedOneWithoutBooksInput
  }

  export type BookUncheckedCreateWithoutPublisherInput = {
    id?: string
    title: string
    publishYear: number
    isbn: number
    description: string
    price: number
    coverUrl?: string | null
    coverDataUri?: string | null
    sold?: number
    transactionId?: string | null
    shoppingCartId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookInput
  }

  export type BookCreateOrConnectWithoutPublisherInput = {
    where: BookWhereUniqueInput
    create: XOR<BookCreateWithoutPublisherInput, BookUncheckedCreateWithoutPublisherInput>
  }

  export type BookUpsertWithWhereUniqueWithoutPublisherInput = {
    where: BookWhereUniqueInput
    update: XOR<BookUpdateWithoutPublisherInput, BookUncheckedUpdateWithoutPublisherInput>
    create: XOR<BookCreateWithoutPublisherInput, BookUncheckedCreateWithoutPublisherInput>
  }

  export type BookUpdateWithWhereUniqueWithoutPublisherInput = {
    where: BookWhereUniqueInput
    data: XOR<BookUpdateWithoutPublisherInput, BookUncheckedUpdateWithoutPublisherInput>
  }

  export type BookUpdateManyWithWhereWithoutPublisherInput = {
    where: BookScalarWhereInput
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyWithoutBookInput>
  }

  export type BookCreateWithoutGenresInput = {
    id?: string
    title: string
    publishYear: number
    isbn: number
    description: string
    price: number
    coverUrl?: string | null
    coverDataUri?: string | null
    sold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authors?: AuthorCreateNestedManyWithoutBooksInput
    publisher: PublisherCreateNestedOneWithoutBookInput
    reviews?: ReviewCreateNestedManyWithoutBookInput
    transaction?: TransactionCreateNestedOneWithoutBooksInput
    shoppingCart?: ShoppingCartCreateNestedOneWithoutBooksInput
  }

  export type BookUncheckedCreateWithoutGenresInput = {
    id?: string
    title: string
    publisherId: string
    publishYear: number
    isbn: number
    description: string
    price: number
    coverUrl?: string | null
    coverDataUri?: string | null
    sold?: number
    transactionId?: string | null
    shoppingCartId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookInput
  }

  export type BookCreateOrConnectWithoutGenresInput = {
    where: BookWhereUniqueInput
    create: XOR<BookCreateWithoutGenresInput, BookUncheckedCreateWithoutGenresInput>
  }

  export type BookUpsertWithWhereUniqueWithoutGenresInput = {
    where: BookWhereUniqueInput
    update: XOR<BookUpdateWithoutGenresInput, BookUncheckedUpdateWithoutGenresInput>
    create: XOR<BookCreateWithoutGenresInput, BookUncheckedCreateWithoutGenresInput>
  }

  export type BookUpdateWithWhereUniqueWithoutGenresInput = {
    where: BookWhereUniqueInput
    data: XOR<BookUpdateWithoutGenresInput, BookUncheckedUpdateWithoutGenresInput>
  }

  export type BookUpdateManyWithWhereWithoutGenresInput = {
    where: BookScalarWhereInput
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyWithoutBooksInput>
  }

  export type UserCreateWithoutReviewsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    nickName?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutUserInput
    shippingAddresses?: AddressCreateNestedManyWithoutUserShippingAddressInput
    creditCards?: CreditCardCreateNestedManyWithoutUserInput
    roles?: RoleCreateNestedManyWithoutUsersInput
    shoppingCart?: ShoppingCartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    nickName?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    shippingAddresses?: AddressUncheckedCreateNestedManyWithoutUserShippingAddressInput
    creditCards?: CreditCardUncheckedCreateNestedManyWithoutUserInput
    shoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type BookCreateWithoutReviewsInput = {
    id?: string
    title: string
    publishYear: number
    isbn: number
    description: string
    price: number
    coverUrl?: string | null
    coverDataUri?: string | null
    sold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authors?: AuthorCreateNestedManyWithoutBooksInput
    publisher: PublisherCreateNestedOneWithoutBookInput
    genres?: GenreCreateNestedManyWithoutBooksInput
    transaction?: TransactionCreateNestedOneWithoutBooksInput
    shoppingCart?: ShoppingCartCreateNestedOneWithoutBooksInput
  }

  export type BookUncheckedCreateWithoutReviewsInput = {
    id?: string
    title: string
    publisherId: string
    publishYear: number
    isbn: number
    description: string
    price: number
    coverUrl?: string | null
    coverDataUri?: string | null
    sold?: number
    transactionId?: string | null
    shoppingCartId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookCreateOrConnectWithoutReviewsInput = {
    where: BookWhereUniqueInput
    create: XOR<BookCreateWithoutReviewsInput, BookUncheckedCreateWithoutReviewsInput>
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutUserInput
    shippingAddresses?: AddressUpdateManyWithoutUserShippingAddressInput
    creditCards?: CreditCardUpdateManyWithoutUserInput
    roles?: RoleUpdateManyWithoutUsersInput
    shoppingCart?: ShoppingCartUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutUserInput
    shippingAddresses?: AddressUncheckedUpdateManyWithoutUserShippingAddressInput
    creditCards?: CreditCardUncheckedUpdateManyWithoutUserInput
    shoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUserInput
  }

  export type BookUpsertWithoutReviewsInput = {
    update: XOR<BookUpdateWithoutReviewsInput, BookUncheckedUpdateWithoutReviewsInput>
    create: XOR<BookCreateWithoutReviewsInput, BookUncheckedCreateWithoutReviewsInput>
  }

  export type BookUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    publishYear?: IntFieldUpdateOperationsInput | number
    isbn?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverDataUri?: NullableStringFieldUpdateOperationsInput | string | null
    sold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authors?: AuthorUpdateManyWithoutBooksInput
    publisher?: PublisherUpdateOneRequiredWithoutBookInput
    genres?: GenreUpdateManyWithoutBooksInput
    transaction?: TransactionUpdateOneWithoutBooksInput
    shoppingCart?: ShoppingCartUpdateOneWithoutBooksInput
  }

  export type BookUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    publisherId?: StringFieldUpdateOperationsInput | string
    publishYear?: IntFieldUpdateOperationsInput | number
    isbn?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverDataUri?: NullableStringFieldUpdateOperationsInput | string | null
    sold?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    shoppingCartId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutShippingAddressesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    nickName?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutUserInput
    creditCards?: CreditCardCreateNestedManyWithoutUserInput
    roles?: RoleCreateNestedManyWithoutUsersInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    shoppingCart?: ShoppingCartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutShippingAddressesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    nickName?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    creditCards?: CreditCardUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    shoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutShippingAddressesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutShippingAddressesInput, UserUncheckedCreateWithoutShippingAddressesInput>
  }

  export type UserUpsertWithoutShippingAddressesInput = {
    update: XOR<UserUpdateWithoutShippingAddressesInput, UserUncheckedUpdateWithoutShippingAddressesInput>
    create: XOR<UserCreateWithoutShippingAddressesInput, UserUncheckedCreateWithoutShippingAddressesInput>
  }

  export type UserUpdateWithoutShippingAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutUserInput
    creditCards?: CreditCardUpdateManyWithoutUserInput
    roles?: RoleUpdateManyWithoutUsersInput
    reviews?: ReviewUpdateManyWithoutUserInput
    shoppingCart?: ShoppingCartUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutShippingAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutUserInput
    creditCards?: CreditCardUncheckedUpdateManyWithoutUserInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserInput
    shoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutTransactionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    nickName?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shippingAddresses?: AddressCreateNestedManyWithoutUserShippingAddressInput
    creditCards?: CreditCardCreateNestedManyWithoutUserInput
    roles?: RoleCreateNestedManyWithoutUsersInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    shoppingCart?: ShoppingCartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    nickName?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shippingAddresses?: AddressUncheckedCreateNestedManyWithoutUserShippingAddressInput
    creditCards?: CreditCardUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    shoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type BookCreateWithoutTransactionInput = {
    id?: string
    title: string
    publishYear: number
    isbn: number
    description: string
    price: number
    coverUrl?: string | null
    coverDataUri?: string | null
    sold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authors?: AuthorCreateNestedManyWithoutBooksInput
    publisher: PublisherCreateNestedOneWithoutBookInput
    genres?: GenreCreateNestedManyWithoutBooksInput
    reviews?: ReviewCreateNestedManyWithoutBookInput
    shoppingCart?: ShoppingCartCreateNestedOneWithoutBooksInput
  }

  export type BookUncheckedCreateWithoutTransactionInput = {
    id?: string
    title: string
    publisherId: string
    publishYear: number
    isbn: number
    description: string
    price: number
    coverUrl?: string | null
    coverDataUri?: string | null
    sold?: number
    shoppingCartId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookInput
  }

  export type BookCreateOrConnectWithoutTransactionInput = {
    where: BookWhereUniqueInput
    create: XOR<BookCreateWithoutTransactionInput, BookUncheckedCreateWithoutTransactionInput>
  }

  export type UserUpsertWithoutTransactionsInput = {
    update: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type UserUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippingAddresses?: AddressUpdateManyWithoutUserShippingAddressInput
    creditCards?: CreditCardUpdateManyWithoutUserInput
    roles?: RoleUpdateManyWithoutUsersInput
    reviews?: ReviewUpdateManyWithoutUserInput
    shoppingCart?: ShoppingCartUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shippingAddresses?: AddressUncheckedUpdateManyWithoutUserShippingAddressInput
    creditCards?: CreditCardUncheckedUpdateManyWithoutUserInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserInput
    shoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUserInput
  }

  export type BookUpsertWithWhereUniqueWithoutTransactionInput = {
    where: BookWhereUniqueInput
    update: XOR<BookUpdateWithoutTransactionInput, BookUncheckedUpdateWithoutTransactionInput>
    create: XOR<BookCreateWithoutTransactionInput, BookUncheckedCreateWithoutTransactionInput>
  }

  export type BookUpdateWithWhereUniqueWithoutTransactionInput = {
    where: BookWhereUniqueInput
    data: XOR<BookUpdateWithoutTransactionInput, BookUncheckedUpdateWithoutTransactionInput>
  }

  export type BookUpdateManyWithWhereWithoutTransactionInput = {
    where: BookScalarWhereInput
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyWithoutBooksInput>
  }

  export type UserCreateWithoutCreditCardsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    nickName?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutUserInput
    shippingAddresses?: AddressCreateNestedManyWithoutUserShippingAddressInput
    roles?: RoleCreateNestedManyWithoutUsersInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    shoppingCart?: ShoppingCartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreditCardsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    nickName?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    shippingAddresses?: AddressUncheckedCreateNestedManyWithoutUserShippingAddressInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    shoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreditCardsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreditCardsInput, UserUncheckedCreateWithoutCreditCardsInput>
  }

  export type UserUpsertWithoutCreditCardsInput = {
    update: XOR<UserUpdateWithoutCreditCardsInput, UserUncheckedUpdateWithoutCreditCardsInput>
    create: XOR<UserCreateWithoutCreditCardsInput, UserUncheckedCreateWithoutCreditCardsInput>
  }

  export type UserUpdateWithoutCreditCardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutUserInput
    shippingAddresses?: AddressUpdateManyWithoutUserShippingAddressInput
    roles?: RoleUpdateManyWithoutUsersInput
    reviews?: ReviewUpdateManyWithoutUserInput
    shoppingCart?: ShoppingCartUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutCreditCardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutUserInput
    shippingAddresses?: AddressUncheckedUpdateManyWithoutUserShippingAddressInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserInput
    shoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUserInput
  }

  export type UserCreateWithoutShoppingCartInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    nickName?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutUserInput
    shippingAddresses?: AddressCreateNestedManyWithoutUserShippingAddressInput
    creditCards?: CreditCardCreateNestedManyWithoutUserInput
    roles?: RoleCreateNestedManyWithoutUsersInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutShoppingCartInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    nickName?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    shippingAddresses?: AddressUncheckedCreateNestedManyWithoutUserShippingAddressInput
    creditCards?: CreditCardUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutShoppingCartInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutShoppingCartInput, UserUncheckedCreateWithoutShoppingCartInput>
  }

  export type BookCreateWithoutShoppingCartInput = {
    id?: string
    title: string
    publishYear: number
    isbn: number
    description: string
    price: number
    coverUrl?: string | null
    coverDataUri?: string | null
    sold?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    authors?: AuthorCreateNestedManyWithoutBooksInput
    publisher: PublisherCreateNestedOneWithoutBookInput
    genres?: GenreCreateNestedManyWithoutBooksInput
    reviews?: ReviewCreateNestedManyWithoutBookInput
    transaction?: TransactionCreateNestedOneWithoutBooksInput
  }

  export type BookUncheckedCreateWithoutShoppingCartInput = {
    id?: string
    title: string
    publisherId: string
    publishYear: number
    isbn: number
    description: string
    price: number
    coverUrl?: string | null
    coverDataUri?: string | null
    sold?: number
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookInput
  }

  export type BookCreateOrConnectWithoutShoppingCartInput = {
    where: BookWhereUniqueInput
    create: XOR<BookCreateWithoutShoppingCartInput, BookUncheckedCreateWithoutShoppingCartInput>
  }

  export type UserUpsertWithoutShoppingCartInput = {
    update: XOR<UserUpdateWithoutShoppingCartInput, UserUncheckedUpdateWithoutShoppingCartInput>
    create: XOR<UserCreateWithoutShoppingCartInput, UserUncheckedCreateWithoutShoppingCartInput>
  }

  export type UserUpdateWithoutShoppingCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutUserInput
    shippingAddresses?: AddressUpdateManyWithoutUserShippingAddressInput
    creditCards?: CreditCardUpdateManyWithoutUserInput
    roles?: RoleUpdateManyWithoutUsersInput
    reviews?: ReviewUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutShoppingCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutUserInput
    shippingAddresses?: AddressUncheckedUpdateManyWithoutUserShippingAddressInput
    creditCards?: CreditCardUncheckedUpdateManyWithoutUserInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserInput
  }

  export type BookUpsertWithWhereUniqueWithoutShoppingCartInput = {
    where: BookWhereUniqueInput
    update: XOR<BookUpdateWithoutShoppingCartInput, BookUncheckedUpdateWithoutShoppingCartInput>
    create: XOR<BookCreateWithoutShoppingCartInput, BookUncheckedCreateWithoutShoppingCartInput>
  }

  export type BookUpdateWithWhereUniqueWithoutShoppingCartInput = {
    where: BookWhereUniqueInput
    data: XOR<BookUpdateWithoutShoppingCartInput, BookUncheckedUpdateWithoutShoppingCartInput>
  }

  export type BookUpdateManyWithWhereWithoutShoppingCartInput = {
    where: BookScalarWhereInput
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyWithoutBooksInput>
  }

  export type UserCreateWithoutRolesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    nickName?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutUserInput
    shippingAddresses?: AddressCreateNestedManyWithoutUserShippingAddressInput
    creditCards?: CreditCardCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    shoppingCart?: ShoppingCartCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRolesInput = {
    id?: string
    email: string
    passwordHash?: string | null
    firstName?: string | null
    middleName?: string | null
    lastName?: string | null
    nickName?: string | null
    profilePicture?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    shippingAddresses?: AddressUncheckedCreateNestedManyWithoutUserShippingAddressInput
    creditCards?: CreditCardUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    shoppingCart?: ShoppingCartUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type UserUpsertWithWhereUniqueWithoutRolesInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRolesInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
  }

  export type UserUpdateManyWithWhereWithoutRolesInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    id?: StringFilter | string
    email?: StringFilter | string
    passwordHash?: StringNullableFilter | string | null
    firstName?: StringNullableFilter | string | null
    middleName?: StringNullableFilter | string | null
    lastName?: StringNullableFilter | string | null
    nickName?: StringNullableFilter | string | null
    profilePicture?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type TransactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    books?: BookUpdateManyWithoutTransactionInput
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    books?: BookUncheckedUpdateManyWithoutTransactionInput
  }

  export type TransactionUncheckedUpdateManyWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUpdateWithoutUserShippingAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    apartmentOrUnit?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUncheckedUpdateWithoutUserShippingAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    apartmentOrUnit?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUncheckedUpdateManyWithoutShippingAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    apartmentOrUnit?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    zipcode?: StringFieldUpdateOperationsInput | string
  }

  export type CreditCardUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    encryptedCreditCardNumber?: StringFieldUpdateOperationsInput | string
    encryptedCCV?: StringFieldUpdateOperationsInput | string
    lastFourDigits?: StringFieldUpdateOperationsInput | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditCardUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    encryptedCreditCardNumber?: StringFieldUpdateOperationsInput | string
    encryptedCCV?: StringFieldUpdateOperationsInput | string
    lastFourDigits?: StringFieldUpdateOperationsInput | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditCardUncheckedUpdateManyWithoutCreditCardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    encryptedCreditCardNumber?: StringFieldUpdateOperationsInput | string
    encryptedCCV?: StringFieldUpdateOperationsInput | string
    lastFourDigits?: StringFieldUpdateOperationsInput | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RoleUncheckedUpdateManyWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    postedAs?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    book?: BookUpdateOneRequiredWithoutReviewsInput
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    postedAs?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookId?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewUncheckedUpdateManyWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    postedAs?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookId?: StringFieldUpdateOperationsInput | string
  }

  export type ShoppingCartUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    books?: BookUpdateManyWithoutShoppingCartInput
  }

  export type ShoppingCartUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    books?: BookUncheckedUpdateManyWithoutShoppingCartInput
  }

  export type ShoppingCartUncheckedUpdateManyWithoutShoppingCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthorUpdateWithoutBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthorUncheckedUpdateWithoutBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthorUncheckedUpdateManyWithoutAuthorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GenreUpdateWithoutBooksInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GenreUncheckedUpdateWithoutBooksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GenreUncheckedUpdateManyWithoutGenresInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    postedAs?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsInput
  }

  export type ReviewUncheckedUpdateWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    postedAs?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type BookUpdateWithoutAuthorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    publishYear?: IntFieldUpdateOperationsInput | number
    isbn?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverDataUri?: NullableStringFieldUpdateOperationsInput | string | null
    sold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publisher?: PublisherUpdateOneRequiredWithoutBookInput
    genres?: GenreUpdateManyWithoutBooksInput
    reviews?: ReviewUpdateManyWithoutBookInput
    transaction?: TransactionUpdateOneWithoutBooksInput
    shoppingCart?: ShoppingCartUpdateOneWithoutBooksInput
  }

  export type BookUncheckedUpdateWithoutAuthorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    publisherId?: StringFieldUpdateOperationsInput | string
    publishYear?: IntFieldUpdateOperationsInput | number
    isbn?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverDataUri?: NullableStringFieldUpdateOperationsInput | string | null
    sold?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    shoppingCartId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutBookInput
  }

  export type BookUncheckedUpdateManyWithoutBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    publisherId?: StringFieldUpdateOperationsInput | string
    publishYear?: IntFieldUpdateOperationsInput | number
    isbn?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverDataUri?: NullableStringFieldUpdateOperationsInput | string | null
    sold?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    shoppingCartId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookUpdateWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    publishYear?: IntFieldUpdateOperationsInput | number
    isbn?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverDataUri?: NullableStringFieldUpdateOperationsInput | string | null
    sold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authors?: AuthorUpdateManyWithoutBooksInput
    genres?: GenreUpdateManyWithoutBooksInput
    reviews?: ReviewUpdateManyWithoutBookInput
    transaction?: TransactionUpdateOneWithoutBooksInput
    shoppingCart?: ShoppingCartUpdateOneWithoutBooksInput
  }

  export type BookUncheckedUpdateWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    publishYear?: IntFieldUpdateOperationsInput | number
    isbn?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverDataUri?: NullableStringFieldUpdateOperationsInput | string | null
    sold?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    shoppingCartId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutBookInput
  }

  export type BookUncheckedUpdateManyWithoutBookInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    publishYear?: IntFieldUpdateOperationsInput | number
    isbn?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverDataUri?: NullableStringFieldUpdateOperationsInput | string | null
    sold?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    shoppingCartId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookUpdateWithoutGenresInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    publishYear?: IntFieldUpdateOperationsInput | number
    isbn?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverDataUri?: NullableStringFieldUpdateOperationsInput | string | null
    sold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authors?: AuthorUpdateManyWithoutBooksInput
    publisher?: PublisherUpdateOneRequiredWithoutBookInput
    reviews?: ReviewUpdateManyWithoutBookInput
    transaction?: TransactionUpdateOneWithoutBooksInput
    shoppingCart?: ShoppingCartUpdateOneWithoutBooksInput
  }

  export type BookUncheckedUpdateWithoutGenresInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    publisherId?: StringFieldUpdateOperationsInput | string
    publishYear?: IntFieldUpdateOperationsInput | number
    isbn?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverDataUri?: NullableStringFieldUpdateOperationsInput | string | null
    sold?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    shoppingCartId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutBookInput
  }

  export type BookUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    publishYear?: IntFieldUpdateOperationsInput | number
    isbn?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverDataUri?: NullableStringFieldUpdateOperationsInput | string | null
    sold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authors?: AuthorUpdateManyWithoutBooksInput
    publisher?: PublisherUpdateOneRequiredWithoutBookInput
    genres?: GenreUpdateManyWithoutBooksInput
    reviews?: ReviewUpdateManyWithoutBookInput
    shoppingCart?: ShoppingCartUpdateOneWithoutBooksInput
  }

  export type BookUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    publisherId?: StringFieldUpdateOperationsInput | string
    publishYear?: IntFieldUpdateOperationsInput | number
    isbn?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverDataUri?: NullableStringFieldUpdateOperationsInput | string | null
    sold?: IntFieldUpdateOperationsInput | number
    shoppingCartId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutBookInput
  }

  export type BookUpdateWithoutShoppingCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    publishYear?: IntFieldUpdateOperationsInput | number
    isbn?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverDataUri?: NullableStringFieldUpdateOperationsInput | string | null
    sold?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authors?: AuthorUpdateManyWithoutBooksInput
    publisher?: PublisherUpdateOneRequiredWithoutBookInput
    genres?: GenreUpdateManyWithoutBooksInput
    reviews?: ReviewUpdateManyWithoutBookInput
    transaction?: TransactionUpdateOneWithoutBooksInput
  }

  export type BookUncheckedUpdateWithoutShoppingCartInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    publisherId?: StringFieldUpdateOperationsInput | string
    publishYear?: IntFieldUpdateOperationsInput | number
    isbn?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverDataUri?: NullableStringFieldUpdateOperationsInput | string | null
    sold?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutBookInput
  }

  export type UserUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutUserInput
    shippingAddresses?: AddressUpdateManyWithoutUserShippingAddressInput
    creditCards?: CreditCardUpdateManyWithoutUserInput
    reviews?: ReviewUpdateManyWithoutUserInput
    shoppingCart?: ShoppingCartUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutUserInput
    shippingAddresses?: AddressUncheckedUpdateManyWithoutUserShippingAddressInput
    creditCards?: CreditCardUncheckedUpdateManyWithoutUserInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserInput
    shoppingCart?: ShoppingCartUncheckedUpdateManyWithoutUserInput
  }

  export type UserUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}